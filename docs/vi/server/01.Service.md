## Giới thiệu

Trong RoxaVN, mọi hành động xử lý nghiệp vụ (business logic) đều được đóng gói trong các Service. Mỗi service là một class kế thừa từ `BaseService`, giúp định nghĩa rõ ràng kiểu dữ liệu đầu vào (Request) và đầu ra (Response) của tác vụ đó.

### BaseService

```ts
class InjectableService {
  static getInstance<T extends new (...args: any) => any>(
    this: T
  ): Promise<InstanceType<T>> {
    return serviceContainer.getAsync(this);
  }
}

abstract class BaseService<
  Request = any,
  Response = any,
> extends InjectableService {
  abstract handle(request: Request, ...args: any[]): Promise<Response>;
}
```

Giải thích

| Thuộc tính | Mô tả                                                                  |
| ---------- | ---------------------------------------------------------------------- |
| `Request`  | Kiểu dữ liệu đầu vào của service (tham số `request`).                  |
| `Response` | Kiểu dữ liệu trả về sau khi service thực thi.                          |
| `handle()` | Hàm bắt buộc phải được implement — chứa logic xử lý chính của service. |

### Dependency Injection

Các **Service** trong RoxaVN được thiết kế theo cơ chế **Dependency Injection (DI)** — cho phép bạn quản lý và sử dụng các phụ thuộc (dependencies) một cách linh hoạt, tối ưu hiệu năng và khả năng mở rộng của hệ thống. Lợi ích của Dependency Injection

1. Dễ dàng thay thế implementation

   * Bạn có thể thay thế một service bằng một implementation khác mà không cần sửa code nơi sử dụng.
   * Ví dụ: thay `EmailService` thật bằng `MockEmailService` trong môi trường test.

2. Chỉ load khi cần thiết (Lazy loading)

   * RoxaVN chỉ khởi tạo (instantiate) service khi có yêu cầu sử dụng thực tế.
   * Điều này giúp thời gian khởi động server nhanh hơn, giảm tài nguyên sử dụng khi có nhiều service.

## Cách dùng

### Khai báo

```ts
import { BaseService, DatabaseService } from '@roxavn/core/server';

@injectable()
export class CreateUserService extends BaseService {
  constructor(
    @inject(DatabaseService) public databaseService: DatabaseService
  ) {
    super();
  }

  async handle(request: { username: string; displayName?: string }) {
    const user = await this.databaseService.dbSession
      .insertInto('user')
      .values({
        id: request.id,
        username: request.username,
        displayName: request.displayName || request.username,
      })
      .returningAll()
      .executeTakeFirstOrThrow();
    return user;
  }
}
```
Giải thích

| Thành phần                 | Mô tả                                                                                                                     |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| `@injectable()`            | Đánh dấu class là **service có thể inject**, cho phép RoxaVN quản lý vòng đời và inject service này vào các service khác. |
| `BaseService`              | Lớp cơ sở mà mọi service kế thừa, bắt buộc phải định nghĩa hàm `handle()`.                                                |
| `@inject(DatabaseService)` | RoxaVN tự động inject `DatabaseService` khi khởi tạo service, giúp code gọn và dễ kiểm thử.                               |
| `handle(request)`          | Hàm xử lý chính, nhận dữ liệu đầu vào và thực hiện logic nghiệp vụ. Ở đây là chèn user mới vào database.                  |

Sử dụng trong service khác

```ts
@injectable()
export class RegisterUserService extends BaseService {
  constructor(
    @inject(CreateUserService) private createUser: CreateUserService
  ) {
    super();
  }

  async handle(request: { username: string; password: string }) {
    const user = await this.createUser.handle({
      username: request.username,
    });
    // thêm xử lý lưu mật khẩu, gửi email, v.v.
    return user;
  }
}
```

### Thay thế implementation

RoxaVN hỗ trợ Dependency Injection (DI) toàn diện — cho phép bạn thay thế (rebind) một service bằng một implementation khác mà không cần thay đổi code gốc.

```ts
@rebind(CreateUserService)
export class MockCreateUserService extends BaseService {
  async handle(request: { username: string; displayName?: string }) {
    // return mock data
    return {
      id: 'mock-id',
      username: request.username,
      displayName: request.displayName || request.username,
      createdAt: new Date().toISOString(),
    };
  }
}
```

Giải thích

| Thành phần               | Mô tả                                                                                       |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| `@rebind(TargetService)` | Thông báo cho RoxaVN rằng service hiện tại **thay thế implementation** của `TargetService`. |
| `TargetService`          | Là class service gốc mà bạn muốn thay thế (ví dụ `CreateUserService`).                      |
| `MockCreateUserService`  | Implementation mới — có thể giả lập hành vi, trả dữ liệu cố định hoặc thêm logic riêng.     |

## Xử lý API

Trong RoxaVN, bạn có thể khai báo một Service để xử lý logic nghiệp vụ tương ứng với một API đã định nghĩa. Service này kế thừa từ `BaseService` và có thể inject các dependency khác (như `DatabaseService`) để thực hiện tác vụ cần thiết.

### Ví dụ

```ts
import { BaseService, DatabaseService, inject, useApi } from '@roxavn/core/server';
import { userApi } from './user.api.js';

@useApi(userApi.search)
export class SearchUsersService extends BaseService {
  static maxUsers = 200;

  constructor(
    @inject(DatabaseService) public databaseService: DatabaseService
  ) {
    super();
  }

  async handle(request: InferApiRequest<typeof userApi.search>) {
    const items = await this.databaseService.dbSession
      .selectFrom('user')
      .selectAll()
      .where((eb) =>
        this.databaseService.utils.makeFilterExpressionsFromObject(eb, request)
      )
      .limit(SearchUsersService.maxUsers)
      .execute();

    return { items };
  }
}
```

Giải thích

| Thành phần                               | Mô tả                                                                                                                                                                      |
| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `@useApi(userApi.search)`                | Liên kết `Service` này với API `userApi.search` và tự inject service này (không cần gọi *@injectable()*). Khi API được gọi, RoxaVN sẽ tự động chạy `handle()` của service. |
| `BaseService`                            | Class cơ sở cho tất cả service trong RoxaVN. Mỗi service phải implement hàm `handle()`.                                                                                    |
| `@inject(DatabaseService)`               | Dùng **Dependency Injection** để lấy `DatabaseService`. RoxaVN sẽ tự khởi tạo và truyền vào service khi cần.                                                               |
| `InferApiRequest<typeof userApi.search>` | Tự động lấy kiểu dữ liệu `request` từ API đã định nghĩa, giúp code có type an toàn.                                                                                        |
| `SearchUsersService.maxUsers`            | Biến static dùng để giới hạn số lượng user trả về.                                                                                                                         |
### Lấy context của request API

Trong RoxaVN, bạn có thể truy cập các thông tin bổ sung (**context**) của request như địa chỉ IP, User-Agent, hoặc dữ liệu được truyền từ **middleware khác**. Cách tiếp cận này giúp định nghĩa input của `Service` trở nên ngắn gọn và rõ ràng, không cần truyền toàn bộ `HTTP Request`, đồng thời tăng khả năng tái sử dụng và tách biệt logic nghiệp vụ khỏi tầng giao tiếp HTTP.

```ts
import { BaseService, type InferApiRequestWithContext, IpAddress, UserAgent } from '@roxavn/core/server';

@useApi(passwordIdentityApi.auth)
export class AuthPasswordIdentityService extends BaseService {
  async handle(
    @IpAddress @UserAgent request: InferApiRequestWithContext<
      typeof passwordIdentityApi.auth,
      [typeof IpAddress, typeof UserAgent]
    >
  ) {
    // implement
  }
}
```

#### Cách hoạt động

Khi một request đến endpoint passwordIdentityApi.auth, RoxaVN sẽ:

1. Parse request body theo ApiRequestSchema.
2. Bổ sung thêm dữ liệu từ các decorator context (IpAddress, UserAgent, ...).
3. Tạo object request hoàn chỉnh → truyền vào handle().

Kết quả là bạn có một request duy nhất chứa cả dữ liệu từ client và context hệ thống:

```js
{
  username: "alice",
  password: "123456",
  ip: "203.113.45.22",
  userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)..."
}
```

#### Các decorator context phổ biến

| Decorator            | Dữ liệu cung cấp                 | Ví dụ                                  |
| -------------------- | -------------------------------- | -------------------------------------- |
| `@IpAddress`         | Địa chỉ IP của client            | {ip: "203.113.45.22"}                  |
| `@UserAgent`         | Thông tin trình duyệt / thiết bị | {userAgent: "Mozilla/5.0 ..."}         |
| `@RequestHostname`   | Hostname của request             | {hostname: "roxavn.com"}               |
| `@RequestOrigin`     | Origin của request               | {origin: "https://roxavn.com"}         |
| `@RequestHost`       | Host của request                 | {host: "roxavn.com:80"}                |
| `@RequestHeaders`    | Toàn bộ headers của request      | {"set-cookie": "", "content-type": ""} |
| `@AuthUserId`        | Id của user đã xác thực          | {"userId": "1e97d11a..."}              |
| `@AuthUserSessionId` | Session id của user đã xác thực  | {"userSessionId": "915d22bd..."}       |

#### Custom decorator

Bạn có thể tự định nghĩa decorator để lấy các dữ liệu tùy chỉnh từ `ApiContext` của API. Decorator giúp bạn tự động trích xuất thông tin cần thiết (ví dụ như *userSessionId*) và truyền vào Service mà không cần thao tác thủ công.

Ví dụ dưới đây tạo decorator `@AuthUserSessionId` để lấy *userSessionId* từ *context.state.userSession*

```ts
import { ContextDecorator, makeApiContextDecorator } from '@roxavn/core/server';

const AuthUserSessionId: ContextDecorator<{ userSessionId: string }> = (
  target,
  propertyKey
) => {
  makeApiContextDecorator(target, propertyKey, 'userSessionId', (context) => {
    const sessionId = context.state.userSession?.id;
    if (!sessionId) {
      throw unauthorizedErrorFactory.make();
    }
    return sessionId;
  });
};
```

## CRUD Services

RoxaVN cung cấp sẵn các **service CRUD** giúp bạn thao tác với các resource (tạo, sửa, xóa, truy vấn) một cách nhanh chóng và nhất quán.

### Tạo mới

Để tạo một resource mới, bạn chỉ cần kế thừa từ `CreateResourceService` và liên kết API tương ứng thông qua decorator `@useApi()`:

```ts
@useApi(userApi.create)
export class CreateUserService extends CreateResourceService<
  InferApiRequest<typeof userApi.create>
> {
  scope = scopes.User;
}
```

Service này tự động ánh xạ request đến API được định nghĩa trong `userApi.create`.
`scope` được sử dụng để xác định tên bảng tương ứng trong cơ sở dữ liệu của resource. Giá trị này giúp framework biết resource hiện tại thuộc bảng nào, phục vụ cho ánh xạ dữ liệu tự động trong quá trình xử lý CRUD.

### Tạo mới với người dùng xác thực

Đối với các resource cần gắn `userId` của người dùng đã đăng nhập, RoxaVN cung cấp lớp mở rộng `CreateResourceWithAuthUserService`. Lớp này tự động thêm `userId` của người thực hiện vào resource khi tạo mới.

Ví dụ:

```ts
@useApi(channelApi.create)
export class CreateChannelService extends CreateResourceWithAuthUserService<
  InferApiRequest<typeof channelApi.create>
> {
  scope = scopes.Channel;
}
```

Khi service này được gọi, framework sẽ tự động lấy thông tin người dùng hiện tại từ context khi xác thực và chèn vào payload của resource trước khi truyền request cho service.

### Sửa

Để cập nhật dữ liệu của một resource, bạn có thể kế thừa từ lớp UpdateResourceService và ánh xạ đến API tương ứng thông qua decorator @useApi():

```ts
@useApi(channelApi.update)
export class UpdateChannelService extends UpdateResourceService<
  InferApiRequest<typeof channelApi.update>
> {
  scope = scopes.Channel;
}
```

### Thêm mới nếu chưa tồn tại (Upsert)

Trong một số trường hợp, bạn cần cập nhật resource nếu đã tồn tại, hoặc tạo mới nếu chưa có — đây chính là cơ chế upsert.
RoxaVN hỗ trợ sẵn lớp `UpsertResourceService` để thực hiện hành vi này.

```ts
@injectable()
export class UpsertFileStorageService extends UpsertResourceService<
  InferApiRequest<typeof fileStorageApi.create> & { id: string; userId: string; }
> {
  scope = scopes.FileStorage;
  conflictColumns = ['id'] as const;
}
```

- `scope`: xác định tên bảng tương ứng trong cơ sở dữ liệu (FileStorage).
- `conflictColumns`: chỉ định danh sách các cột dùng để phát hiện xung đột (ví dụ: id). Khi phát hiện xung đột, framework sẽ tự động thực hiện hành động cập nhật thay vì tạo mới.

### Xóa

```ts
@useApi(projectApi.delete)
export class DeleteProjectService extends DeleteResourceService {
  scope = scopes.Project;
}
```

### Lấy 1

Để truy xuất thông tin chi tiết của một resource dựa trên khóa định danh `id`, bạn có thể kế thừa từ lớp GetResourceService.

```ts
@injectable()
export class GetFileStorageService extends GetResourceService<
  typeof scopes.FileStorage
> {
  scope = scopes.FileStorage;
}
```

### Lấy nhiều theo phân trang

`GetManyResourcesService` cung cấp cơ chế truy vấn dữ liệu có phân trang, tự động xử lý các tham số lọc, sắp xếp và giới hạn bản ghi trả về.

```ts
@useApi(projectApi.getMany)
export class GetProjectsService extends GetManyResourcesService<
  InferApiRequest<typeof projectApi.getMany>,
  typeof scopes.Project
> {
  scope = scopes.Project;
}
```

#### Cơ chế lọc tự động theo tên cột và toán tử

RoxaVN định nghĩa chuẩn format cho tham số request theo cấu trúc `${columnName}_${operator}`. Cấu trúc này cho phép `GetManyResourcesService` tự động ánh xạ tham số request thành điều kiện truy vấn tương ứng trong cơ sở dữ liệu.

```ts
getMany: projectSource.getMany({
  request: Type.PaginationRequest({
    type: Type.Optional(Type.String()),
    userId: Type.Optional(Type.String()),
    name_iContains: Type.Optional(Type.String()),
    isPublic: Type.Optional(Type.Boolean()),
    createdDate_between: Type.Optional(
      Type.Array(Type.Date(), { maxItems: 2, minItems: 2 })
    ),
    orderBy: Type.Optional(Type.OrderBy(Type.Union([Type.Literal('id')]))),
  }),
}),
```

- `name_iContains`: lọc các bản ghi có cột `name` chứa chuỗi ký tự được truyền vào, không phân biệt hoa thường.
- `createdDate_between`: lọc các bản ghi có `createdDate` nằm trong khoảng giá trị được chỉ định
- `type`: lọc theo giá trị chính xác của cột `type`

#### Các toán tử được hỗ trợ 

`GetManyResourcesService` hỗ trợ đầy đủ các toán tử phổ biến trong truy vấn dữ liệu:

| Toán tử                                                                                        | Mô tả                                            |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| `<`, `<=`, `>`, `>=`, `!=`, `=`                                                                | So sánh giá trị thông thường                     |
| `->`, `->>`                                                                                    | Truy xuất thuộc tính trong cột JSON              |
| `like`, `ilike`, `startsWith`, `endsWith`, `iStartsWith`, `iEndsWith`, `contains`, `iContains` | Tìm kiếm theo mẫu, có/không phân biệt hoa thường |
| `includes`                                                                                     | Kiểm tra phần tử nằm trong mảng                  |
| `between`, `betweenExclusive`                                                                  | Lọc trong khoảng giá trị                         |
| `fts`                                                                                          | Full-text search                                 |
| `in`, `notIn`                                                                                  | Lọc theo danh sách giá trị                       |
| `isNull`, `isNotNull`                                                                          | Kiểm tra giá trị rỗng                            |

### Lấy tất cả

`GetAllResourcesService` được sử dụng để truy xuất toàn bộ danh sách resource mà không cần phân trang. Service này hỗ trợ đầy đủ các cơ chế lọc, sắp xếp và tìm kiếm tương tự như `GetManyResourcesService`, giúp việc truy vấn dữ liệu trở nên thống nhất và đơn giản hơn.

```ts
@useApi(statisticConfigApi.getAll)
export class GetAllStatisticConfigsService extends GetAllResourcesService<
  InferApiRequest<typeof statisticConfigApi.getAll>,
  typeof scopes.StatisticConfig
> {
  scope = scopes.StatisticConfig;
}
```
