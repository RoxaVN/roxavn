## Cron job

RoxaVN hỗ trợ Cron Job cho phép bạn định nghĩa và chạy các tác vụ định kỳ một cách tự động — ví dụ như dọn dẹp dữ liệu, gửi email, đồng bộ dữ liệu, hoặc chạy báo cáo.

Một Cron Job được khai báo bằng decorator `@useCronJob()` với tham số là biểu thức cron. RoxaVN cung cấp sẵn các biểu thức thông dụng qua enum `CronExpression` để sử dụng dễ dàng.

Ví dụ:

```ts
import { BaseService, CronExpression, DatabaseService, inject } from '@roxavn/core/server';

@useCronJob(CronExpression.EVERY_DAY_AT_1AM)
export class YourCronJobService extends BaseService {
  constructor(
    @inject(DatabaseService) private databaseService: DatabaseService,
  ) {
    super();
  }

  async handle() {
    // implement
  }
}
```

Giải thích:

- `@useCronJob()`: đăng ký service này làm cron job.
- `CronExpression.EVERY_DAY_AT_1AM`: chạy job mỗi ngày lúc 1:00 sáng.
- `handle()`: là phương thức chứa logic sẽ được thực thi khi cron job được kích hoạt.
- `@inject(DatabaseService)`: sử dụng dependency injection để truy cập các service khác trong hệ thống.

## Job theo event

Ngoài cron job theo thời gian, RoxaVN còn hỗ trợ job theo event — cho phép bạn lắng nghe và thực thi logic tự động khi một sự kiện cụ thể xảy ra trong hệ thống.

Cơ chế này hoạt động tương tự như event-driven architecture, giúp các service tách biệt và mở rộng dễ dàng mà không cần phụ thuộc trực tiếp vào nhau.

### 1. Gửi (phát) event

```ts
@injectable()
export class Service extends BaseService {
  constructor(@inject(JobManager) jobManager: JobManager) {
    super();
  }

  async handle() {
    const eventData = { message: 'this is a message' };
    this.jobManager.dispatch('eventName', eventData);
  }
}
```

Ở đây:

- `JobManager.dispatch(eventName, data)` sẽ kích hoạt tất cả các job đã đăng ký lắng nghe sự kiện `eventName`.
- `eventData` là dữ liệu truyền kèm theo event, có thể chứa thông tin cần thiết cho job xử lý.

### 2. Lắng nghe và xử lý event

```ts
@useJob({name: 'eventName'})
export class YourJobService extends BaseService {
  handle(eventData: {message: string}) {
    // implement
    console.log(eventData); 
  }
}
```

Ở đây:

- `@useJob({name: 'eventName'})` đăng ký service này để lắng nghe sự kiện `eventName`.
- Phương thức `handle()` sẽ tự động được gọi mỗi khi event được phát.

## Job khi tài nguyên thay đổi

Các decorator `handleResourceInsert()`, `handleResourceUpdate()`, `handleResourceDelete()` là tiện ích mở rộng (wrapper) của `useJob()`, được thiết kế để tự động kích hoạt khi một **resource (tài nguyên)** trong hệ thống được thêm mới, cập nhật hoặc xóa.

Ví dụ dưới đây minh họa cách tạo một service xử lý sự kiện khi có message mới được tạo:

```ts
import { InferResource } from '@roxavn/core';
import { BaseService } from '@roxavn/core/server';

@handleResourceInsert({ scope: scopes.Message })
export class CreateMessageNoticeService extends BaseService {
  async handle(data: { resource: InferResource<typeof scopes.Message> }) {
    // Thực thi logic khi có Message mới
    console.log('New message created:', data);
  }
}
```

Khi một bản ghi `Message` mới được thêm vào cơ sở dữ liệu, RoxaVN sẽ tự động kích hoạt job này và truyền dữ liệu resource tương ứng vào hàm `handle()`.

Cơ chế này giúp tách biệt rõ ràng giữa **xử lý nghiệp vụ chính** và **xử lý tác vụ phụ (side-effect)**, giúp hệ thống dễ mở rộng và bảo trì hơn.

## Job khi API thực thi thành công

`useApiSuccessJob()` là một tiện ích mở rộng (wrapper) của `useJob()`, giúp bạn **lắng nghe và xử lý các sự kiện** khi một API được thực thi thành công.

Khi API được gọi và trả về kết quả thành công (HTTP 2xx), RoxaVN sẽ tự động kích hoạt service được đăng ký thông qua decorator này, đồng thời truyền dữ liệu response vào hàm `handle()`.

Ví dụ:

```ts
import { BaseService, InferApiSuccessData } from '@roxavn/core/server';

@useApiSuccessJob(taskApi.create)
export class CreateSubTaskNoticeService extends BaseService {
  async handle(data: InferApiSuccessData<typeof taskApi.create>) {
    // Thực thi logic sau khi API taskApi.create thành công
    console.log('A new task has been created:', data);
  }
}
```

Cơ chế này đặc biệt hữu ích để:

* Gửi thông báo sau khi một hành động thành công (ví dụ: tạo task, gửi tin nhắn, phê duyệt đơn,...).
* Thực hiện các tác vụ nền (background jobs) mà không làm chậm phản hồi của API chính.
* Giảm sự phụ thuộc giữa luồng xử lý chính và luồng side-effect.

## Job khi API thực thi thất bại

`useApiErrorJob()` là một tiện ích mở rộng (wrapper) của `useJob()`, giúp bạn **lắng nghe và xử lý các sự kiện khi một API gặp lỗi trong quá trình thực thi**.

Khi API được gọi và trả về lỗi (HTTP status code từ 4xx đến 5xx), RoxaVN sẽ tự động kích hoạt service được đăng ký bằng decorator này, đồng thời truyền dữ liệu lỗi vào phương thức `handle()`.

Ví dụ:

```ts
import { BaseService, InferApiErrorData } from '@roxavn/core/server';

@useApiErrorJob(taskApi.create)
export class CreateSubTaskNoticeService extends BaseService {
  async handle(data: InferApiErrorData<typeof taskApi.create>) {
    // Xử lý khi API taskApi.create bị lỗi
    console.error('Task creation failed:', data.error);
  }
}
```

Cơ chế này đặc biệt hữu ích trong các trường hợp:

* Ghi log hoặc lưu trữ thông tin lỗi phục vụ việc theo dõi và giám sát.
* Gửi cảnh báo (notification, email, webhook, v.v.) khi API quan trọng bị lỗi.
* Thực hiện các hành động khôi phục (retry, rollback, cleanup, ...) khi một quy trình thất bại.

## Middleware

`@useJobMiddleware()` được sử dụng để đăng ký **Job Middleware**, cho phép can thiệp vào quy trình thực thi của job (trước, trong hoặc sau khi job chạy). Middleware hoạt động tương tự như **HTTP middleware**, giúp bạn dễ dàng triển khai các cơ chế như logging, retry, theo dõi hiệu suất, hay xử lý lỗi tập trung.

### Ví dụ

Ví dụ sau minh họa một middleware đơn giản dùng để ghi log quá trình thực thi job:

```ts
import { JobContext, MiddlewareService, useJobMiddleware } from '@roxavn/core/server';

@useJobMiddleware()
export class LogJobMiddleware extends MiddlewareService {
  static priority = 1;

  async handle({ state, job }: JobContext, next: () => Promise<void>) {
    try {
      console.log(`[Job Start] ${job.name}`, state);
      await next(); // Tiếp tục thực thi job tiếp theo trong chuỗi middleware
      console.log(`[Job End] ${job.name}`);
    } catch (e: any) {
      console.error(`[Job Error] ${job.name}:`, e);
      throw e; // Tiếp tục ném lỗi để hệ thống xử lý
    }
  }
}
```

### Giải thích

* `@useJobMiddleware()` Decorator dùng để đánh dấu class là một Job Middleware, để RoxaVN tự động nhận diện và đăng ký.

* `MiddlewareService` Là lớp cơ sở (base class) giúp định nghĩa cấu trúc chuẩn của một middleware.
  Tất cả middleware nên kế thừa từ lớp này.

* `static priority` Xác định thứ tự thực thi giữa các middleware. Middleware có `priority` nhỏ hơn sẽ được chạy trước.

* `handle(context, next)` Là phương thức chính của middleware.
  * *context*: Chứa thông tin về trạng thái job (`state`) và metadata của job (`job`).
  * *next()*: Hàm callback dùng để tiếp tục luồng xử lý sang middleware kế tiếp hoặc job chính.
