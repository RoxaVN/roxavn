## Cron job

RoxaVN hỗ trợ Cron Job cho phép bạn định nghĩa và chạy các tác vụ định kỳ một cách tự động — ví dụ như dọn dẹp dữ liệu, gửi email, đồng bộ dữ liệu, hoặc chạy báo cáo.

Một Cron Job được khai báo bằng decorator `@serverModule.useCronJob()` với tham số là biểu thức cron. RoxaVN cung cấp sẵn các biểu thức thông dụng qua enum `CronExpression` để sử dụng dễ dàng.

Ví dụ:

```ts
import { BaseService, CronExpression, DatabaseService, inject } from '@roxavn/core/server';

@serverModule.useCronJob(CronExpression.EVERY_DAY_AT_1AM)
export class YourCronJobService extends BaseService {
  constructor(
    @inject(DatabaseService) private databaseService: DatabaseService,
  ) {
    super();
  }

  async handle() {
    // implement
  }
}
```

Giải thích:

- `@serverModule.useCronJob()`: đăng ký service này làm cron job.
- `CronExpression.EVERY_DAY_AT_1AM`: chạy job mỗi ngày lúc 1:00 sáng.
- `handle()`: là phương thức chứa logic sẽ được thực thi khi cron job được kích hoạt.
- `@inject(DatabaseService)`: sử dụng dependency injection để truy cập các service khác trong hệ thống.

## Job theo event

Ngoài cron job theo thời gian, RoxaVN còn hỗ trợ job theo event — cho phép bạn lắng nghe và thực thi logic tự động khi một sự kiện cụ thể xảy ra trong hệ thống.

Cơ chế này hoạt động tương tự như event-driven architecture, giúp các service tách biệt và mở rộng dễ dàng mà không cần phụ thuộc trực tiếp vào nhau.

### 1. Gửi (phát) event

```ts
export class Service extends BaseService {
  constructor(@inject(JobManager) jobManager: JobManager) {
    super();
  }

  async handle() {
    const eventData = { message: 'this is a message' };
    this.jobManager.emit('eventName', eventData);
  }
}
```

Ở đây:

- `JobManager.emit(eventName, data)` sẽ kích hoạt tất cả các job đã đăng ký lắng nghe sự kiện `eventName`.
- `eventData` là dữ liệu truyền kèm theo event, có thể chứa thông tin cần thiết cho job xử lý.

### 2. Lắng nghe và xử lý event

```ts
@serverModule.useJob('eventName')
export class YourJobService extends BaseService {
  handle(eventData: {message: string}) {
    // implement
    console.log(eventData); 
  }
}
```

Ở đây:

- `@serverModule.useJob('eventName')` đăng ký service này để lắng nghe sự kiện `eventName`.
- Phương thức `handle()` sẽ tự động được gọi mỗi khi event được phát.

> ⚠️ **Lưu ý**  
> Bạn có thể khởi chạy nhiều worker để xử lý các job bằng lệnh `npx roxavn worker --normal`. Tuy nhiên, đối với job này, **chỉ một worker duy nhất** sẽ được chọn để thực thi nhằm tránh việc xử lý trùng lặp.

## Job khi tài nguyên thay đổi

`serverModule.useResourceChangeJob()` là một tiện ích mở rộng (wrapper) của `serverModule.useJob()`, được thiết kế để tự động kích hoạt khi một **resource (tài nguyên)** trong hệ thống có sự thay đổi — như thêm mới **(insert)**, cập nhật **(update)**, hay xóa **(delete)**.

Ví dụ dưới đây minh họa cách tạo một service xử lý sự kiện khi có message mới được tạo:

```ts
import { InferResource } from '@roxavn/core';
import { BaseService } from '@roxavn/core/server';

@serverModule.useResourceChangeJob({
  scope: scopes.Message,
  action: 'insert', // lắng nghe sự kiện thêm mới Message
})
export class CreateMessageNoticeService extends BaseService {
  async handle(data: InferResource<typeof scopes.Message>) {
    // Thực thi logic khi có Message mới
    console.log('New message created:', data);
  }
}
```

Khi một bản ghi `Message` mới được thêm vào cơ sở dữ liệu, RoxaVN sẽ tự động kích hoạt job này và truyền dữ liệu resource tương ứng vào hàm `handle()`.

Cơ chế này giúp tách biệt rõ ràng giữa **xử lý nghiệp vụ chính** và **xử lý tác vụ phụ (side-effect)**, giúp hệ thống dễ mở rộng và bảo trì hơn.

## Job khi API thực thi thành công

`serverModule.useApiSuccessJob()` là một tiện ích mở rộng (wrapper) của `serverModule.useJob()`, giúp bạn **lắng nghe và xử lý các sự kiện** khi một API được thực thi thành công.

Khi API được gọi và trả về kết quả thành công (HTTP 2xx), RoxaVN sẽ tự động kích hoạt service được đăng ký thông qua decorator này, đồng thời truyền dữ liệu response vào hàm `handle()`.

Ví dụ:

```ts
import { BaseService, InferApiSuccessData } from '@roxavn/core/server';

@serverModule.useApiSuccessJob(taskApi.create)
export class CreateSubTaskNoticeService extends BaseService {
  async handle(data: InferApiSuccessData<typeof taskApi.create>) {
    // Thực thi logic sau khi API taskApi.create thành công
    console.log('A new task has been created:', data);
  }
}
```

Cơ chế này đặc biệt hữu ích để:

* Gửi thông báo sau khi một hành động thành công (ví dụ: tạo task, gửi tin nhắn, phê duyệt đơn,...).
* Thực hiện các tác vụ nền (background jobs) mà không làm chậm phản hồi của API chính.
* Giảm sự phụ thuộc giữa luồng xử lý chính và luồng side-effect.

## Job khi API thực thi thất bại

`serverModule.useApiErrorJob()` là một tiện ích mở rộng (wrapper) của `serverModule.useJob()`, giúp bạn **lắng nghe và xử lý các sự kiện khi một API gặp lỗi trong quá trình thực thi**.

Khi API được gọi và trả về lỗi (HTTP status code từ 4xx đến 5xx), RoxaVN sẽ tự động kích hoạt service được đăng ký bằng decorator này, đồng thời truyền dữ liệu lỗi vào phương thức `handle()`.

Ví dụ:

```ts
import { BaseService, InferApiErrorData } from '@roxavn/core/server';

@serverModule.useApiErrorJob(taskApi.create)
export class CreateSubTaskNoticeService extends BaseService {
  async handle(data: InferApiErrorData<typeof taskApi.create>) {
    // Xử lý khi API taskApi.create bị lỗi
    console.error('Task creation failed:', data.error);
  }
}
```

Cơ chế này đặc biệt hữu ích trong các trường hợp:

* Ghi log hoặc lưu trữ thông tin lỗi phục vụ việc theo dõi và giám sát.
* Gửi cảnh báo (notification, email, webhook, v.v.) khi API quan trọng bị lỗi.
* Thực hiện các hành động khôi phục (retry, rollback, cleanup, ...) khi một quy trình thất bại.
