## DatabaseService

RoxaVN sử dụng **PostgreSQL** làm cơ sở dữ liệu chính và tích hợp thư viện **Kysely** để hỗ trợ việc tạo và thực thi truy vấn SQL một cách **an toàn, có kiểm tra kiểu tĩnh (type-safe)**.

`DatabaseService` được cung cấp sẵn nhằm **đơn giản hóa quá trình kết nối và thao tác với database**, giúp các service có thể truy vấn, insert, update, hoặc delete dữ liệu mà không cần cấu hình thủ công kết nối đến PostgreSQL.

Ví dụ:

```ts
import { BaseService, DatabaseService, inject } from '@roxavn/core/server';

@serverModule.injectable()
export class CreateUserService extends BaseService {
  constructor(
    @inject(DatabaseService) public databaseService: DatabaseService
  ) {
    super();
  }

  async handle(request: { username: string; displayName?: string }) {
    const user = await this.databaseService.dbSession
      .insertInto('user')
      .values({
        id: request.id,
        username: request.username,
        displayName: request.displayName || request.username,
      })
      .returningAll()
      .executeTakeFirstOrThrow();
    return user;
  }
}
```

### Giải thích

* `DatabaseService.dbSession`: Là phiên làm việc (**session**) được RoxaVN tự động khởi tạo và **đã được bọc (wrapped)** sẵn trên Kysely, giúp bạn có thể truy vấn cơ sở dữ liệu một cách trực tiếp mà không cần quản lý kết nối thủ công.

* Hỗ trợ **transaction tự động** giúp đảm bảo tính toàn vẹn dữ liệu — mọi truy vấn trong một request sẽ được rollback nếu có lỗi.

* Hỗ trợ **type inference**: Kysely tự động kiểm tra kiểu dữ liệu của cột, giúp phát hiện lỗi truy vấn ngay từ lúc compile thay vì khi runtime.

### Đồng bộ kiểu dữ liệu (Type Synchronization)

Để đảm bảo **kiểm tra kiểu (type-checking)** chính xác giữa code và database, RoxaVN hỗ trợ lệnh đồng bộ kiểu tự động thông qua công cụ CLI.

Khi bạn chạy lệnh `npx roxavn sync -d` RoxaVN sẽ:

* Kết nối đến cơ sở dữ liệu,
* Lấy thông tin cấu trúc (schema) của **tất cả các bảng thuộc module hiện tại**,
* Và tự động **cập nhật kiểu dữ liệu TypeScript tương ứng** trong thư mục `.web/schemas/`.

Nhờ vậy, bạn có thể viết truy vấn Kysely với kiểu dữ liệu an toàn và chính xác tuyệt đối — mọi lỗi sai cột, sai kiểu, hay truy vấn sai bảng sẽ được phát hiện ngay khi biên dịch (compile time).

#### Giới hạn truy cập giữa các module

Mỗi module RoxaVN chỉ có thể truy vấn đến **các bảng thuộc chính module đó**. Cơ chế này giúp:

* Giữ module độc lập
* Tránh phụ thuộc chéo giữa các module,
* Tăng tính ổn định và dễ bảo trì của hệ thống.

#### Truy vấn bảng của module khác

Trong trường hợp bạn viết **plugin** (hoặc một module mở rộng) và cần truy vấn đến bảng của **module chính**, bạn có thể khai báo trong `package.json` như sau:

```json
{
  "roxavn": {
    "useEntities": ["@roxavn/module-location"]
  }
}
```

Khai báo này cho phép plugin truy cập và sử dụng schema của module `@roxavn/module-location` khi đồng bộ kiểu.

### InjectDatabaseService

Nếu service của bạn chỉ cần thao tác với database, RoxaVN cung cấp sẵn lớp tiện ích `InjectDatabaseService` giúp bạn không cần inject thủ công `DatabaseService` nữa.

Bạn chỉ cần **kế thừa (extends)** lớp này, và có thể truy cập trực tiếp session thông qua thuộc tính `this.dbSession`. Nó giúp code ngắn gọn, rõ ràng hơn.

Ví dụ:

```ts
@serverModule.useApi(userApi.search)
export class SearchUsersService extends InjectDatabaseService {
  async handle(request: InferApiRequest<typeof userApi.search>) {
    // Truy cập trực tiếp dbSession
    const items = await this.dbSession
      .selectFrom('user')
      .selectAll()
      .where((eb) =>
        this.databaseService.utils.makeFilterExpressionsFromObject(eb, request)
      )
      .limit(100)
      .execute();

    return { items };
  }
}
```

## Migration

Bạn có thể tạo **migration** lần đầu cho module dễ dàng bằng lệnh `npx roxavn-ts migration`. Khi chạy lệnh này, RoxaVN sẽ:

1. **Đọc danh sách các scope** được định nghĩa trong file `src/base/access.ts`.
2. **Tự động sinh migration** cho các bảng tương ứng với các scope được khai báo.

Điều này giúp đảm bảo cấu trúc database luôn đồng bộ với định nghĩa resource trong module, giảm thiểu lỗi sai hoặc thiếu sót khi thay đổi schema.

### Tạo migration thủ công

Nếu bạn muốn tạo một migration độc lập, không phụ thuộc vào scope, có thể sử dụng lệnh:

```bash
npx roxavn gen migration
```

Lệnh này sẽ sinh ra một file migration mẫu với cấu trúc như sau:

```ts
import { MigrateService } from '@roxavn/core/server';
import { scopes } from '../../base/index.js';
import { serverModule } from '../module.js';

@serverModule.useMigration()
export class Test extends MigrateService {
  static timestamp = 1761029162570;

  async up() {
    // Thực hiện các thay đổi (tạo bảng, thêm cột, v.v.)
  }

  async down() {
    // Hoàn tác các thay đổi trong `up`
  }
}
```

Trong đó:

* `timestamp` là giá trị duy nhất giúp RoxaVN xác định **thứ tự migration**.
* `up()` chứa logic nâng cấp (ví dụ: tạo bảng, thêm cột, cập nhật dữ liệu...).
* `down()` chứa logic rollback tương ứng để hoàn tác thay đổi khi cần.

### Thao tác migration

Các câu lệnh thường dùng với migration

| Lệnh                                   | Mô tả                                |
| -------------------------------------- | ------------------------------------ |
| `npx roxavn-ts migration:up`           | Chạy tất cả migration chưa thực thi  |
| `npx roxavn-ts migration:revert`       | Rollback migration vừa chạy gần nhất |
| `npx roxavn-ts migration:down -n name` | Hoàn tác migration có tên cụ thể     |

