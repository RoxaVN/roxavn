## Giới thiệu

Vì RoxaVN được thiết kế theo hướng modular, mỗi module có thể export các **Component** để các module khác tái sử dụng. Tuy nhiên, điều này nảy sinh một vấn đề:

> Các plugin hoặc module mở rộng thường muốn thêm tính năng mới hoặc tùy chỉnh hành vi cho các Component đã có.

Để giải quyết vấn đề đó, RoxaVN giới thiệu cơ chế *Template Service* giúp:

* Thay thế toàn bộ logic hoặc giao diện mặc định.
* Mở rộng và ghi đè có chọn lọc các phần cụ thể.

Nhờ vậy, hệ thống trở nên linh hoạt, dễ dàng mở rộng mà không cần sửa đổi trực tiếp Component gốc.

## Ví dụ

### Khai báo Template Service

`TemplateService` được dùng để định nghĩa một *template* có thể được thay thế hoặc mở rộng logic hiển thị trong các `Component`. Mỗi `TemplateService` đại diện cho một vùng giao diện có thể được tùy chỉnh bởi các module khác.

Ví dụ, ta khai báo một template để hiển thị thông tin người dùng:

```ts
import { TemplateService } from '@roxavn/core/web';

const userInfoTemplate = new TemplateService<{ username: string }>('userInfo');
```

Ở đây:

* `'userInfo'` là tên định danh của template.
* Kiểu dữ liệu `{ username: string }` mô tả *props* mà template sẽ nhận được.

### Sử dụng Template trong Component chính

Sau khi khai báo, ta có thể sử dụng template trong component thông qua `Template` component của RoxaVN.

```tsx
import { Template } from '@roxavn/core/web';

function UserInfo(props: { username: string }) {
  return <div>{props.username}</div>;
}

function Component() {
  return (
    <div>
      <Template
        service={userInfoTemplate}
        component={UserInfo}
        props={{ username: 'Woody' }}
      />
    </div>
  );
}
```

Giải thích:

* `service`: truyền vào instance của `TemplateService`.
* `component`: component gốc được hiển thị mặc định.
* `props`: dữ liệu truyền vào component đó.

Khi render, RoxaVN sẽ hiển thị `UserInfo` hoặc phiên bản đã được thay thế (nếu có middleware được đăng ký).

### Thay thế hoặc mở rộng cách hiển thị

Để thay đổi hoặc bổ sung logic hiển thị cho template, bạn có thể sử dụng `addMiddleware`. Middleware có thể chỉnh sửa `props`, thay đổi component, hoặc xử lý logic trước khi render.

Ví dụ, thêm tiền tố `"Hello "` vào tên người dùng:

```ts
import { TemplateService } from '@roxavn/core/web';

userInfoTemplate.addMiddleware((context) => {
  context.props.username = `Hello ${context.props.username}`;
}, Object.values(TemplateService.namespaces));
```

Giải thích:

* `context.props` chứa dữ liệu truyền vào template.
* `addMiddleware` nhận callback để xử lý dữ liệu trước khi render.
* `Object.values(TemplateService.namespaces)` cho phép middleware được áp dụng trong tất cả các namespace của RoxaVN.

Hoặc thay thế cả Component mặc định

```ts
import { TemplateService } from '@roxavn/core/web';

function NewUserInfo(props: { username: string }) {
  return <div>Hello {props.username}</div>;
}

userInfoTemplate.addMiddleware((context) => {
  context.component = NewUserInfo;
}, Object.values(TemplateService.namespaces));
```

## Template Namespaces

Trong RoxaVN, mỗi *Template Service* hoạt động trong một **namespace** tương ứng với khu vực ứng dụng hiện tại.
Namespace giúp phân tách logic hiển thị giữa các ứng dụng khác nhau (Admin, Personal, Application chính), cho phép middleware chỉ áp dụng trong phạm vi mong muốn.

### Các namespace mặc định

RoxaVN định nghĩa sẵn **3 template namespace**:

| Namespace                          | Ứng dụng                     | Đường dẫn tương ứng |
| ---------------------------------- | ---------------------------- | ------------------- |
| `TemplateService.namespaces.ADMIN` | Admin Dashboard              | `/admin/apps`       |
| `TemplateService.namespaces.ME`    | Personal Profile             | `/me`               |
| `TemplateService.namespaces.APP`   | Ứng dụng chính (Application) | `/`                 |

### Giới hạn phạm vi hoạt động của Middleware

Khi đăng ký middleware bằng `addMiddleware`, bạn có thể chỉ định danh sách namespace mà middleware được phép hoạt động.

Ví dụ:
Nếu bạn chỉ muốn middleware thay đổi giao diện khi người dùng truy cập **Admin Dashboard**, cấu hình như sau:

```ts
userInfoTemplate.addMiddleware((context) => {
  context.component = NewUserInfo;
}, [TemplateService.namespaces.ADMIN]);
```

Giải thích:

* `context.component` cho phép thay thế component gốc (`UserInfo`) bằng một component mới (`NewUserInfo`).
* Mảng namespace `[TemplateService.namespaces.ADMIN]` đảm bảo middleware **chỉ áp dụng** trong môi trường Admin.
