## Giới thiệu

Trong RoxaVN, mọi hành động xử lý nghiệp vụ (business logic) đều được đóng gói trong các Service. Mỗi service là một class kế thừa từ `BaseService`, giúp định nghĩa rõ ràng kiểu dữ liệu đầu vào (Request) và đầu ra (Response) của tác vụ đó.

### BaseService

```ts
class InjectableService {
  static getInstance<T extends new (...args: any) => any>(
    this: T
  ): Promise<InstanceType<T>> {
    return serviceContainer.getAsync(this);
  }
}

abstract class BaseService<
  Request = any,
  Response = any,
> extends InjectableService {
  abstract handle(request: Request, ...args: any[]): Promise<Response>;
}
```

Giải thích

| Thuộc tính | Mô tả                                                                  |
| ---------- | ---------------------------------------------------------------------- |
| `Request`  | Kiểu dữ liệu đầu vào của service (tham số `request`).                  |
| `Response` | Kiểu dữ liệu trả về sau khi service thực thi.                          |
| `handle()` | Hàm bắt buộc phải được implement — chứa logic xử lý chính của service. |

### Dependency Injection

Các **Service** trong RoxaVN được thiết kế theo cơ chế **Dependency Injection (DI)** — cho phép bạn quản lý và sử dụng các phụ thuộc (dependencies) một cách linh hoạt, tối ưu hiệu năng và khả năng mở rộng của hệ thống. Lợi ích của Dependency Injection

1. Dễ dàng thay thế implementation

   * Bạn có thể thay thế một service bằng một implementation khác mà không cần sửa code nơi sử dụng.
   * Ví dụ: thay `EmailService` thật bằng `MockEmailService` trong môi trường test.

2. Chỉ load khi cần thiết (Lazy loading)

   * RoxaVN chỉ khởi tạo (instantiate) service khi có yêu cầu sử dụng thực tế.
   * Điều này giúp thời gian khởi động server nhanh hơn, giảm tài nguyên sử dụng khi có nhiều service.

## Cách dùng

### Khai báo

```ts
import { BaseService, DatabaseService } from '@roxavn/core/server';

@serverModule.injectable()
export class CreateUserService extends BaseService {
  constructor(
    @inject(DatabaseService) public databaseService: DatabaseService
  ) {
    super();
  }

  async handle(request: { username: string; displayName?: string }) {
    const user = await this.databaseService.dbSession
      .insertInto('user')
      .values({
        id: request.id,
        username: request.username,
        displayName: request.displayName || request.username,
      })
      .returningAll()
      .executeTakeFirstOrThrow();
    return user;
  }
}
```
Giải thích

| Thành phần                   | Mô tả                                                                                                                     |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| `@serverModule.injectable()` | Đánh dấu class là **service có thể inject**, cho phép RoxaVN quản lý vòng đời và inject service này vào các service khác. |
| `BaseService`                | Lớp cơ sở mà mọi service kế thừa, bắt buộc phải định nghĩa hàm `handle()`.                                                |
| `@inject(DatabaseService)`   | RoxaVN tự động inject `DatabaseService` khi khởi tạo service, giúp code gọn và dễ kiểm thử.                               |
| `handle(request)`            | Hàm xử lý chính, nhận dữ liệu đầu vào và thực hiện logic nghiệp vụ. Ở đây là chèn user mới vào database.                  |

Sử dụng trong service khác

```ts
@serverModule.injectable()
export class RegisterUserService extends BaseService {
  constructor(
    @inject(CreateUserService) private createUser: CreateUserService
  ) {
    super();
  }

  async handle(request: { username: string; password: string }) {
    const user = await this.createUser.handle({
      username: request.username,
    });
    // thêm xử lý lưu mật khẩu, gửi email, v.v.
    return user;
  }
}
```

### Thay thế implementation

RoxaVN hỗ trợ Dependency Injection (DI) toàn diện — cho phép bạn thay thế (rebind) một service bằng một implementation khác mà không cần thay đổi code gốc.

```ts
@serverModule.rebind(CreateUserService)
export class MockCreateUserService extends BaseService {
  async handle(request: { username: string; displayName?: string }) {
    // return mock data
    return {
      id: 'mock-id',
      username: request.username,
      displayName: request.displayName || request.username,
      createdAt: new Date().toISOString(),
    };
  }
}
```

Giải thích

| Thành phần                            | Mô tả                                                                                       |
| ------------------------------------- | ------------------------------------------------------------------------------------------- |
| `@serverModule.rebind(TargetService)` | Thông báo cho RoxaVN rằng service hiện tại **thay thế implementation** của `TargetService`. |
| `TargetService`                       | Là class service gốc mà bạn muốn thay thế (ví dụ `CreateUserService`).                      |
| `MockCreateUserService`               | Implementation mới — có thể giả lập hành vi, trả dữ liệu cố định hoặc thêm logic riêng.     |

## Xử lý API

Trong RoxaVN, bạn có thể khai báo một Service để xử lý logic nghiệp vụ tương ứng với một API đã định nghĩa. Service này kế thừa từ `BaseService` và có thể inject các dependency khác (như `DatabaseService`) để thực hiện tác vụ cần thiết.

### Ví dụ

```ts
import { BaseService, DatabaseService, inject } from '@roxavn/core/server';
import { userApi } from './user.api.js';

@serverModule.useApi(userApi.search)
export class SearchUsersService extends BaseService {
  static maxUsers = 200;

  constructor(
    @inject(DatabaseService) public databaseService: DatabaseService
  ) {
    super();
  }

  async handle(request: InferApiRequest<typeof userApi.search>) {
    const items = await this.databaseService.dbSession
      .selectFrom('user')
      .selectAll()
      .where((eb) =>
        this.databaseService.utils.makeFilterExpressionsFromObject(eb, request)
      )
      .limit(SearchUsersService.maxUsers)
      .execute();

    return { items };
  }
}
```

Giải thích

| Thành phần                               | Mô tả                                                                                                                                                                                   |
| ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `@serverModule.useApi(userApi.search)`   | Liên kết `Service` này với API `userApi.search` và tự inject service này (không cần gọi *@serverModule.injectable()*). Khi API được gọi, RoxaVN sẽ tự động chạy `handle()` của service. |
| `BaseService`                            | Class cơ sở cho tất cả service trong RoxaVN. Mỗi service phải implement hàm `handle()`.                                                                                                 |
| `@inject(DatabaseService)`               | Dùng **Dependency Injection** để lấy `DatabaseService`. RoxaVN sẽ tự khởi tạo và truyền vào service khi cần.                                                                            |
| `InferApiRequest<typeof userApi.search>` | Tự động lấy kiểu dữ liệu `request` từ API đã định nghĩa, giúp code có type an toàn.                                                                                                     |
| `SearchUsersService.maxUsers`            | Biến static dùng để giới hạn số lượng user trả về.                                                                                                                                      |
### Lấy context của request API

Trong RoxaVN, bạn có thể truy cập các thông tin bổ sung (**context**) của request như địa chỉ IP, User-Agent, hoặc dữ liệu được truyền từ **middleware khác**. Cách tiếp cận này giúp định nghĩa input của `Service` trở nên ngắn gọn và rõ ràng, không cần truyền toàn bộ `HTTP Request`, đồng thời tăng khả năng tái sử dụng và tách biệt logic nghiệp vụ khỏi tầng giao tiếp HTTP.

```ts
import { BaseService, type InferApiRequestWithContext, IpAddress, UserAgent } from '@roxavn/core/server';

@serverModule.useApi(passwordIdentityApi.auth)
export class AuthPasswordIdentityService extends BaseService {
  async handle(
    @IpAddress @UserAgent request: InferApiRequestWithContext<
      typeof passwordIdentityApi.auth,
      [typeof IpAddress, typeof UserAgent]
    >
  ) {
    // implement
  }
}
```

#### Cách hoạt động

Khi một request đến endpoint passwordIdentityApi.auth, RoxaVN sẽ:

1. Parse request body theo ApiRequestSchema.
2. Bổ sung thêm dữ liệu từ các decorator context (IpAddress, UserAgent, ...).
3. Tạo object request hoàn chỉnh → truyền vào handle().

Kết quả là bạn có một request duy nhất chứa cả dữ liệu từ client và context hệ thống:

```js
{
  username: "alice",
  password: "123456",
  ip: "203.113.45.22",
  userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)..."
}
```

#### Các decorator context phổ biến

| Decorator            | Dữ liệu cung cấp                 | Ví dụ                                  |
| -------------------- | -------------------------------- | -------------------------------------- |
| `@IpAddress`         | Địa chỉ IP của client            | {ip: "203.113.45.22"}                  |
| `@UserAgent`         | Thông tin trình duyệt / thiết bị | {userAgent: "Mozilla/5.0 ..."}         |
| `@RequestHostname`   | Hostname của request             | {hostname: "roxavn.com"}               |
| `@RequestOrigin`     | Origin của request               | {origin: "https://roxavn.com"}         |
| `@RequestHost`       | Host của request                 | {host: "roxavn.com:80"}                |
| `@RequestHeaders`    | Toàn bộ headers của request      | {"set-cookie": "", "content-type": ""} |
| `@AuthUserId`        | Id của user đã xác thực          | {"userId": "1e97d11a..."}              |
| `@AuthUserSessionId` | Session id của user đã xác thực  | {"userSessionId": "915d22bd..."}       |

#### Custom decorator

Bạn có thể tự định nghĩa decorator để lấy các dữ liệu tùy chỉnh từ `RouterContext` của API. Decorator giúp bạn tự động trích xuất thông tin cần thiết (ví dụ như *userSessionId*) và truyền vào Service mà không cần thao tác thủ công.

Ví dụ dưới đây tạo decorator `@AuthUserSessionId` để lấy *userSessionId* từ *context.state.userSession*

```ts
import { ContextDecorator, makeApiContextDecorator } from '@roxavn/core/server';

const AuthUserSessionId: ContextDecorator<{ userSessionId: string }> = (
  target,
  propertyKey
) => {
  makeApiContextDecorator(target, propertyKey, 'userSessionId', (context) => {
    const sessionId = context.state.userSession?.id;
    if (!sessionId) {
      throw unauthorizedErrorFactory.make();
    }
    return sessionId;
  });
};
```
