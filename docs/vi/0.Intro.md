## Tại sao lại có RoxaVN

Tôi từng lăn lộn qua các thể loại dự án: game, blockchain, mạng xã hội, ERP, thương mại điện tử. Mỗi lần bắt đầu dự án, việc đầu tiên tôi phải làm là dựng lại cái “project base” — giống như mỗi lần nấu ăn phải rửa nồi, vo gạo, thổi cơm lại từ đầu. Lặp đi lặp lại riết chán, tôi mới nghĩ: “Ủa, sao mình không tạo luôn cái framework có sẵn hết mọi thứ, muốn gì chỉ cần ráp module như chơi Lego?”  
Thế là RoxaVN ra đời — mỗi module là một miếng Lego xịn, lập trình viên chỉ cần lắp ghép lại theo mô hình kinh doanh của riêng mình. Không cần làm đầu bếp, chỉ cần biết xào lại là có món ngon 😎 

## Triết lý thiết kế

Để module có thể “chạy tốt trên mọi địa hình”, chúng phải **đơn giản đến mức không thể đơn giản hơn nữa**. Nói cách khác, RoxaVN sống theo triết lý **KISS – Keep It Simple, Stupid**.

Mỗi module chỉ biết những việc cơ bản như tạo, sửa, xóa entity — không hoa mỹ, không phức tạp, không “deep learning” làm gì. Cả cách code cho RoxaVN cũng phải ngắn gọn, nhìn vào hiểu liền, không cần tài liệu dài lê thê. Code càng dài thì lỗi càng nhiều, dev càng mệt, PM càng stress, và QA càng buồn ngủ.

Trường hợp hoàn hảo nhất là **không cần code mà vẫn chạy được** – kiểu như “framework biết lo cho bạn hết”. Nếu đã có thư viện làm sẵn, thì chỉ cần chạy `npm install` mà thôi — đừng phát minh lại cái bánh xe 🤭

Tại sao tôi lại chọn nguyên tắc KISS chứ không phải SOLID hay nguyên tắc nào khác vì nó đơn giản dễ nhớ. Bản thân tôi cũng không nhớ SOLID là viết tắt của 5 từ gì 😂. Khi code bạn không cần nhớ phải tuân theo 5 quy tắc nào, chỉ cần nhớ **code ngắn nhất** có thể thôi.

## Lựa chọn công nghệ

Phần này giải thích rõ cho việc lựa chọn công nghệ để xây dựng nên RoxaVN

### 🏗️ 1. Monolith hay Microservices  

Ngày xưa, **Monolith** là “vua” — tất cả dồn vào một khối. Debug dễ, deploy nhanh, nhưng chỉ cần đụng nhẹ một tí là… “nổ toàn bộ”.  
Rồi người ta sinh ra **Microservices** — chia nhỏ hệ thống, mỗi service lo một việc.  
Nghe sang lắm, nhưng chạy rồi mới biết: “Một hệ thống, ngàn bug, triệu log” 😅  

#### 💀 Điểm yếu huyền thoại của Microservices  

1. **Quản lý mệt như nuôi bầy mèo** 🐈  
   Mỗi service là một con mèo: build riêng, deploy riêng, log riêng, bug riêng.  
   Có 30 service là bạn thành **người trông sở thú phần mềm**.  

2. **Đồng bộ dữ liệu = chơi xếp hình trong bão** 🌪️  
   Service A lưu user, B lưu order, C lưu payment.  
   Muốn thống kê doanh thu → chúc mừng, bạn unlock *minigame “Ghép Dữ Liệu Liên Service”*.  

3. **Transaction liên service: ác mộng thật sự** 😵  
   Rollback 3 service cùng lúc? Chúc bạn may mắn.  
   Dữ liệu nhất quán trong mơ, còn thực tế thì… “thôi đừng hỏi”.  

4. **Giao tiếp dễ ‘đột tử’** ⚡  
   Network là thứ “nay sống mai chết”.  
   Một service timeout, kéo theo cả chuỗi domino — log thì dài như biên niên sử công ty.  

5. **DevOps nhìn thấy là muốn chuyển nghề** 💀  
   Mỗi lần deploy phải build mấy chục image, đẩy mấy chục container.  
   Có Kubernetes thì đỡ hơn, nhưng cũng chỉ là “đỡ đau chứ chưa hết đau”.  

#### 💡 Modular Monolith – Người hùng thầm lặng  

RoxaVN chọn **Modular Monolith**, vì nó giữ đúng tinh thần **KISS**:  

| Microservices | Modular Monolith (RoxaVN) |
|----------------|-----------------------------|
| Mỗi service chạy riêng → 10 app, 10 port, 10 container 😫 | Một lệnh `npm start` là lên hết 😌 |
| Transaction xuyên service → saga pattern, event bus, headache 💥 | Mọi thứ chung DB → rollback 1 phát ăn ngay 🧘 |
| API call → network delay, timeout, retry | Import module → chạy nhanh như ánh sáng ⚡ |
| Đồng bộ dữ liệu giữa các service là 1 thách thức | Truy vấn đơn giản vì tất cả dữ liệu trong 1 DB |

#### Module RoxaVN

Mỗi module RoxaVN sẽ là 1 Javascript package với git repo độc lập. Việc này giúp cho nhiều team có thể phát triển các module song song và không phụ thuộc với nhau. Module RoxaVN sẽ gồm 2 loại:

- **Module:** tương tự như service trong Microservices.
  Mỗi module có bảng riêng, không foreign key chéo. Nếu cần dữ liệu module khác, gọi API mà nó cung cấp.  
- **Plugin:** phần mở rộng cho module.
  Plugin có thể truy cập bảng của module chính qua cấu hình và thường có prefix `plugin-` trong package name. Ví dụ như `@roxavn/plugin-message-reaction` là plugin thêm tính năng reaction cho `@roxavn/module-message`

Ngoài ra những module dòi hỏi tính năng đặc thù hoặc hiệu suất cao nên tách ra như 1 hệ thống độc lập, không nên nằm trong RoxaVN (ví dụ như upload file với MinIO, hay stream video với Mediasoup, ...)

### ⚔️ 2. JavaScript song kiếm hợp bích cùng TypeScript  

JavaScript không phải “ngôn ngữ mạnh nhất vũ trụ”, nhưng lại là **ngôn ngữ được lòng cả backend lẫn frontend**. Và đó chính là lý do RoxaVN chọn nó làm bảo kiếm của mình 🥷

Khi **frontend và backend cùng nói chung một thứ tiếng**, bạn sẽ nhận được những buff sức mạnh sau:  

- 🧘‍♂️ **Code liền mạch, tâm hồn thanh tịnh**  
  Đang viết React quay sang NodeJS vẫn thấy thân quen, không còn cảnh đang `console.log` vui vẻ rồi chuyển sang `System.out.println` và mất mood.  

- 🔄 **Server – Client chung huyết thống**  
  Cả hai dùng chung thư viện, chung kiểu dữ liệu, chung niềm vui. Bạn chỉ cần định nghĩa request/response API ở một nơi, cả backend lẫn frontend đều hiểu — như hai người yêu cùng tài khoản Netflix ❤️  

- 👩‍💻 **Tuyển dev dễ như ăn bánh**  
  Không còn drama “ông này biết backend nhưng không biết React”, hay “chị kia chỉ làm frontend”. Giờ chỉ cần **một ngôn ngữ – full stack liền mạch**. Dev frontend có thể làm backend, dev backend có thể… build giao diện (nếu dám 😏).  


Nhưng đừng xem thường JavaScript! Dù không nhanh như Rust, không gọn như Go, không “cứng” như C++, nó lại có một siêu năng lực mà mấy ngôn ngữ kia mơ cũng không có:

> 💥 Bạn có thể lưu **mã JavaScript trong database**, backend chỉ việc lấy ra, **chạy thẳng luôn!**  

Không cần build, không cần compile, không cần cầu nguyện. Tính năng này giúp RoxaVN **tùy biến linh hoạt như ninja biến hình**, và được dùng triệt để trong `@roxavn/module-workflow` để xử lý mọi logic theo yêu cầu.  

Còn **TypeScript** thì sao? Đó chính là **thanh kiếm thứ hai** của RoxaVN ⚔️  

Nếu JavaScript là nghệ sĩ tự do, thì TypeScript là người quản lý khó tính — đảm bảo mọi input/output của API đều gọn gàng, rõ ràng, không nhầm kiểu.  

Mỗi module và plugin trong RoxaVN là một package **ESModule** chuẩn chỉnh, giúp build client nhẹ hơn với **Tree Shaking** 🪶 

RoxaVN dùng với Node 20+ với npm. Trong tương lai sẽ cân nhắc chuyển sang Bun.

> RoxaVN dùng JavaScript để **linh hoạt như nước** và TypeScript để **chắc chắn như thép**.

### 🧙‍♂️ 3. Postgres – Thần giữ của 💰  

Trong thế giới lập trình, **data là vàng**, mà đã là vàng thì phải có thần giữ của canh chừng cẩn thận. RoxaVN chọn **PostgreSQL** – vị thần vừa “ngầu”, vừa “có học”, vừa “không đòi tiền bản quyền” 😎  

Vì sao không chọn NoSQL?  
Vì RoxaVN cần **transaction**, mà NoSQL thì… thôi, nói nhẹ nhàng là “sống tự do quá mức” 😅  

#### 🔥 Những lý do khiến Postgres xứng đáng ngồi ghế “thần giữ của”  

- 🪄 **Full Text Search cực mạnh:**  
  Không cần rước thêm ElasticSearch về nhà cho tốn RAM, tốn công đồng bộ. Chỉ cần Postgres là đủ – *simple is beautiful*.  

- 🗺️ **PostGIS – phép thuật bản đồ:**  
  Truy vấn theo tọa độ, khoảng cách, hình dạng... Postgres làm ngon hết. Nói thật, chỉ thiếu mỗi việc nó vẽ bản đồ ra giấy cho bạn thôi 😂  

- 📡 **Bắn event realtime cho client:**  
  Khi data thay đổi, Postgres có thể “bắn tín hiệu” cho app biết ngay – như thể database đang thì thầm: *“Ê, dữ liệu mày vừa đổi kìa.”*  

- 🧰 **Và cả tá tính năng thần thánh khác:**  
  Từ JSONB, trigger, view, function, đến extension… đủ để bạn xây cả lâu đài dữ liệu mà không cần thêm lính.  

#### 🪶 Bonus: Hóa thân thành CockroachDB

Nếu bạn muốn Postgres của mình có **siêu năng lực phân tán**, chạy đa node, chịu lỗi như “gián đến từ hậu tận thế”, thì chỉ cần chuyển sang **CockroachDB** — cùng cú pháp SQL, không cần sửa code, và hệ thống của bạn sẽ “bất tử” như boss cuối trong game 💀

## Mô hình tổng quan

RoxaVN là framework **fullstack**, lo luôn cả backend lẫn frontend. Nói cách khác, “trọn gói từ A đến Z”.  

### Lớp người dùng
1. **Nhà cung cấp:** tổ chức hoặc cá nhân “dựng cửa hàng, mở dịch vụ”, cung cấp đủ thứ cho khách hàng.
2. **Khách hàng:** người dùng cuối, là thượng đế của bạn 👑.

### Giao diện người dùng
1. **Admin dashboard:** nơi nhà cung cấp vào “điều hành thế giới” — quản lý user, dịch vụ, v.v.  
   - 🛠️ Truy cập: `/admin/apps`  
2. **Personal profile:** chỗ khách hàng tự “tút lại profile”, chỉnh tên, thay avatar, đổi mood.  
   - 👤 Truy cập: `/me`  
3. **Custom application:** nếu thấy chưa đủ, bạn có thể “nấu món riêng”, phát triển ứng dụng web tùy mô hình kinh doanh.
