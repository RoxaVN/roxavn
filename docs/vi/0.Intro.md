## Tại sao lại có RoxaVN

Tôi từng lăn lộn qua các thể loại dự án: game, blockchain, mạng xã hội, ERP, thương mại điện tử. Mỗi lần bắt đầu dự án, việc đầu tiên tôi phải làm là dựng lại cái “project base” — giống như mỗi lần nấu ăn phải rửa nồi, vo gạo, thổi cơm lại từ đầu. Lặp đi lặp lại riết chán, tôi mới nghĩ: “Ủa, sao mình không tạo luôn cái framework có sẵn hết mọi thứ, muốn gì chỉ cần ráp module như chơi Lego?”  
Thế là RoxaVN ra đời — mỗi module là một miếng Lego xịn, lập trình viên chỉ cần lắp ghép lại theo mô hình kinh doanh của riêng mình. Không cần làm đầu bếp, chỉ cần biết xào lại là có món ngon 😎 

## Triết lý thiết kế

Để module có thể “chạy tốt trên mọi địa hình”, chúng phải **đơn giản đến mức không thể đơn giản hơn nữa**. Nói cách khác, RoxaVN sống theo triết lý **KISS – Keep It Simple, Stupid**.

Mỗi module chỉ biết những việc cơ bản như tạo, sửa, xóa entity — không hoa mỹ, không phức tạp, không “deep learning” làm gì. Cả cách code cho RoxaVN cũng phải ngắn gọn, nhìn vào hiểu liền, không cần tài liệu dài lê thê. Code càng dài thì lỗi càng nhiều, dev càng mệt, PM càng stress, và QA càng buồn ngủ.

Trường hợp hoàn hảo nhất là **không cần code mà vẫn chạy được** – kiểu như “framework biết lo cho bạn hết”. Nếu đã có thư viện làm sẵn, thì chỉ cần chạy `npm install` mà thôi — đừng phát minh lại cái bánh xe 🤭

Tại sao tôi lại chọn nguyên tắc KISS chứ không phải SOLID hay nguyên tắc nào khác vì nó đơn giản dễ nhớ. Bản thân tôi cũng không nhớ SOLID là viết tắt của 5 từ gì 😂. Khi code bạn không cần nhớ phải tuân theo 5 quy tắc nào, chỉ cần nhớ **code ngắn nhất** có thể thôi.

## Lựa chọn công nghệ

Phần này giải thích rõ cho việc lựa chọn công nghệ để xây dựng nên RoxaVN

### 🏗️ 1. Monolith hay Microservices  

Ngày xưa, **Monolith** là “vua” — tất cả dồn vào một khối. Debug dễ, deploy nhanh, nhưng chỉ cần đụng nhẹ một tí là… “nổ toàn bộ”.  
Rồi người ta sinh ra **Microservices** — chia nhỏ hệ thống, mỗi service lo một việc.  
Nghe sang lắm, nhưng chạy rồi mới biết: “Một hệ thống, ngàn bug, triệu log” 😅  

#### 💀 Điểm yếu huyền thoại của Microservices  

1. **Quản lý mệt như nuôi bầy mèo** 🐈  
   Mỗi service là một con mèo: build riêng, deploy riêng, log riêng, bug riêng.  
   Có 30 service là bạn thành **người trông sở thú phần mềm**.  

2. **Đồng bộ dữ liệu = chơi xếp hình trong bão** 🌪️  
   Service A lưu user, B lưu order, C lưu payment.  
   Muốn thống kê doanh thu → chúc mừng, bạn unlock *minigame “Ghép Dữ Liệu Liên Service”*.  

3. **Transaction liên service: ác mộng thật sự** 😵  
   Rollback 3 service cùng lúc? Chúc bạn may mắn.  
   Dữ liệu nhất quán trong mơ, còn thực tế thì… “thôi đừng hỏi”.  

4. **Giao tiếp dễ ‘đột tử’** ⚡  
   Network là thứ “nay sống mai chết”.  
   Một service timeout, kéo theo cả chuỗi domino — log thì dài như biên niên sử công ty.  

5. **DevOps nhìn thấy là muốn chuyển nghề** 💀  
   Mỗi lần deploy phải build mấy chục image, đẩy mấy chục container.  
   Có Kubernetes thì đỡ hơn, nhưng cũng chỉ là “đỡ đau chứ chưa hết đau”.  

#### 💡 Modular Monolith – Người hùng thầm lặng

RoxaVN chọn **Modular Monolith**, vì nó giữ đúng tinh thần **KISS**:  

| Microservices | Modular Monolith (RoxaVN) |
|----------------|-----------------------------|
| Mỗi service chạy riêng → 10 app, 10 port, 10 container 😫 | Một lệnh `npm start` là lên hết 😌 |
| Transaction xuyên service → saga pattern, event bus, headache 💥 | Mọi thứ chung DB → rollback 1 phát ăn ngay 🧘 |
| API call → network delay, timeout, retry | Import module → chạy nhanh như ánh sáng ⚡ |
| Đồng bộ dữ liệu giữa các service là 1 thách thức | Truy vấn đơn giản vì tất cả dữ liệu trong 1 DB |

Thực tế thì Modular Monolith vẫn đang bị underrated một cách đau lòng 💔. Mọi người hay bị cuốn vào hype “micro-đủ-thứ”, trong khi tư tưởng **Modular** thực ra có thể áp dụng cho cả backend lẫn frontend luôn. Bạn đâu cần phải dựng nguyên một **microfrontend** phức tạp và nặng như con voi chỉ để hiển thị vài component nhỏ 😅. Với RoxaVN, chỉ cần:

```ts
import { AwesomeComponent } from "@roxavn/module-xyz";
```

và boom 💥 — bạn đã dùng component từ module khác ngon lành, không cần proxy, không cần build chéo, không cần cầu nguyện với webpack thần thánh.

Còn nếu bạn muốn chỉ tải component khi user thực sự cần, hãy tận dụng `dynamic import()` của ESModule – vừa giảm kích thước bundle ban đầu, vừa khiến user thấy app “mượt như Sunsilk” 🧈.

#### Module RoxaVN

Mỗi module RoxaVN sẽ là 1 Javascript package với git repo độc lập, chứa cả code backend lẫn frontend. Việc này giúp cho nhiều team có thể phát triển các module song song và không phụ thuộc với nhau. Module RoxaVN sẽ gồm 2 loại:

- **Module:** tương tự như service trong Microservices.
  Mỗi module có bảng riêng, không foreign key chéo. Nếu cần dữ liệu module khác, gọi API mà nó cung cấp.  
- **Plugin:** phần mở rộng cho module.
  Plugin có thể truy cập bảng của module chính qua cấu hình và thường có prefix `plugin-` trong package name. Ví dụ như `@roxavn/plugin-message-reaction` là plugin thêm tính năng reaction cho `@roxavn/module-message`

Ngoài ra những module dòi hỏi tính năng đặc thù hoặc hiệu suất cao nên tách ra như 1 hệ thống độc lập, không nên nằm trong RoxaVN (ví dụ như upload file với MinIO, hay stream video với Mediasoup, ...)

### ⚔️ 2. JavaScript song kiếm hợp bích cùng TypeScript  

JavaScript không phải “ngôn ngữ mạnh nhất vũ trụ”, nhưng lại là **ngôn ngữ được lòng cả backend lẫn frontend**. Và đó chính là lý do RoxaVN chọn nó làm bảo kiếm của mình 🥷

Khi **frontend và backend cùng nói chung một thứ tiếng**, bạn sẽ nhận được những buff sức mạnh sau:  

- 🧘‍♂️ **Code liền mạch, tâm hồn thanh tịnh**  
  Đang viết React quay sang NodeJS vẫn thấy thân quen, không còn cảnh đang `console.log` vui vẻ rồi chuyển sang `System.out.println` và mất mood.  

- 🔄 **Server – Client chung huyết thống**  
  Cả hai dùng chung thư viện, chung kiểu dữ liệu, chung niềm vui. Bạn chỉ cần định nghĩa request/response API ở một nơi, cả backend lẫn frontend đều hiểu — như hai người yêu cùng tài khoản Netflix ❤️  

- 👩‍💻 **Tuyển dev dễ như ăn bánh**  
  Không còn drama “ông này biết backend nhưng không biết React”, hay “chị kia chỉ làm frontend”. Giờ chỉ cần **một ngôn ngữ – full stack liền mạch**. Dev frontend có thể làm backend, dev backend có thể… build giao diện (nếu dám 😏).  

Nhưng đừng xem thường JavaScript! Dù không nhanh như Rust, không gọn như Go, không “cứng” như C++, nó lại có một siêu năng lực mà mấy ngôn ngữ kia mơ cũng không có:

> 💥 Bạn có thể lưu **mã JavaScript trong database**, backend chỉ việc lấy ra, **chạy thẳng luôn!**  

Không cần build, không cần compile, không cần cầu nguyện. Tính năng này giúp RoxaVN **tùy biến linh hoạt như ninja biến hình**, và được dùng triệt để trong `@roxavn/module-workflow` để xử lý mọi logic theo yêu cầu.  

Còn **TypeScript** thì sao? Đó chính là **thanh kiếm thứ hai** của RoxaVN ⚔️  

Nếu JavaScript là nghệ sĩ tự do, thì TypeScript là người quản lý khó tính — đảm bảo mọi input/output của API đều gọn gàng, rõ ràng, không nhầm kiểu.  

Mỗi module và plugin trong RoxaVN là một package **ESModule** chuẩn chỉnh, giúp build client nhẹ hơn với **Tree Shaking** 🪶 

RoxaVN dùng với Node 20+ và npm. Trong tương lai sẽ cân nhắc chuyển sang Bun.

> RoxaVN dùng JavaScript để **linh hoạt như nước** và TypeScript để **chắc chắn như thép**.

### 🧙‍♂️ 3. Postgres – Thần giữ của 💰  

Trong thế giới lập trình, **data là vàng**, mà đã là vàng thì phải có thần giữ của canh chừng cẩn thận. RoxaVN chọn **PostgreSQL** – vị thần vừa “ngầu”, vừa “có học”, vừa “không đòi tiền bản quyền” 😎  

Vì sao không chọn NoSQL?  
Vì RoxaVN cần **transaction**, mà NoSQL thì… thôi, nói nhẹ nhàng là “sống tự do quá mức” 😅  

#### 🔥 Những lý do khiến Postgres xứng đáng ngồi ghế “thần giữ của”  

- 🪄 **Full Text Search cực mạnh:**  
  Không cần rước thêm ElasticSearch về nhà cho tốn RAM, tốn công đồng bộ. Chỉ cần Postgres là đủ – *simple is beautiful*.  

- 🗺️ **PostGIS – phép thuật bản đồ:**  
  Truy vấn theo tọa độ, khoảng cách, hình dạng... Postgres làm ngon hết. Nói thật, chỉ thiếu mỗi việc nó vẽ bản đồ ra giấy cho bạn thôi 😂  

- 📡 **Bắn event realtime cho client:**  
  Khi data thay đổi, Postgres có thể “bắn tín hiệu” cho app biết ngay – như thể database đang thì thầm: *“Ê, dữ liệu mày vừa đổi kìa.”*  

- 🧰 **Và cả tá tính năng thần thánh khác:**  
  Từ JSONB, trigger, view, function, đến extension… đủ để bạn xây cả lâu đài dữ liệu mà không cần thêm lính.  

#### 🪶 Bonus: Hóa thân thành CockroachDB

Nếu bạn muốn Postgres của mình có **siêu năng lực phân tán**, chạy đa node, chịu lỗi như “gián đến từ hậu tận thế”, thì chỉ cần chuyển sang **CockroachDB** — cùng cú pháp SQL, không cần sửa code, và hệ thống của bạn sẽ “bất tử” như boss cuối trong game 💀

### ⚛️ 4. React – Cánh tay phải của RoxaVN 💙  

RoxaVN chọn **React** không phải vì hype, mà vì nó có hệ sinh thái to như chợ Bến Thành. Cần vẽ flow? Có **ReactFlow**. Cần editor xịn? Có **Puck Editor**. Cần biểu đồ lung linh? **Recharts** lo hết 🎨 và 1 loạt các framework UI khác nữa. Một hệ sinh thái có đủ “đồ chơi” như vậy, dev chỉ cần biết cách import đúng là có thể “sống vui – code khỏe” 🤓.

Tôi cũng từng *crush* **SolidJS** – nhỏ này nhanh, gọn, render lẹ như ninja. Nhưng tiếc là “đi chơi” với nó hơi cô đơn, vì thư viện còn ít.  Muốn vẽ biểu đồ hay kéo thả node là phải tự cầm dao… à nhầm, code tay 😅. Còn **Vue** và **Angular** thì sao? Hai ông này cũng mạnh, cộng đồng đông, nhưng lại có thói quen “trộn đồ ăn” – code JS mà phải khai báo UI trong file HTML. Mỗi lần nhảy qua nhảy lại giữa script và template, tôi cảm giác như xem phim mà phải tua tới lui phụ đề 🤯.

**React** với **JSX** thì khác – HTML và JS sống chung một nhà, hòa hợp như cặp đôi song ca ăn ý 🎤. Bạn code liền mạch, suy nghĩ không bị ngắt quãng, và có thể viết UI như đang kể chuyện tình giữa component và state 💞.

#### 💔 React Router vs Next.js  

Thị trường **framework fullstack** cho React thì nhiều vô kể: Next.js, Gatsby, Astro… nói chung là “đi 3 bước là đụng một framework mới ra lò”. Nhưng RoxaVN lại có đặc thù riêng:

> Mỗi module là một thế giới nhỏ, và **mỗi module export ra các page riêng**.  
> Khi chạy, RoxaVN sẽ tự động gom tất cả các page đó lại, ráp thành một website hoàn chỉnh – như ghép Lego thành lâu đài 🏰  

Vấn đề là… Next.js không chịu chơi kiểu đó 😩. Nó bắt bạn phải đặt tất cả page trong một thư mục `pages` cố định, giống như bắt dev phải dồn hết code vào một vali rồi bảo “tự sắp đi nhé”. Cộng đồng Next.js thì to như fandom K-pop, tài liệu nhiều như tiểu thuyết, nhưng tiếc là RoxaVN và Next.js không cùng “tần số tự do”. Thế là đành nói lời chia tay nhẹ nhàng:

> “Không phải lỗi của em, cũng chẳng phải lỗi của anh – chỉ là ta không hợp cấu trúc thư mục thôi.” 😢  

Gatsby và Astro cũng thử bước vào, nhưng rồi cũng phải ra đi vì… quá cứng nhắc về định tuyến (routing).  

Chỉ có **React Router** – người bạn “cũ” (tiền thân là Remix) – mới thật sự hiểu RoxaVN cần gì:  

> “Custom route tự do, đường nào cũng được, miễn đừng crash.” 🛣️

Và thế là RoxaVN đã tìm thấy tri kỷ của mình ❤️. Một người bạn linh hoạt, đáng tin, và không bắt dev phải theo khuôn mẫu.

### 🧩 5. Kysely - Cuộc gặp gỡ định mệnh

Những phiên bản đầu tiên của RoxaVN từng “yêu say đắm” **TypeORM** – một công cụ ORM giúp đồng bộ entity với database và tạo migration tự động. Ban đầu, mọi thứ đều đẹp: chỉ cần định nghĩa entity là database tự sinh ra, dev không cần động tay vào SQL — cảm giác sung sướng như có AI viết hộ code 🧠✨. Nhưng càng gắn bó lâu, TypeORM càng lộ nhiều “tật xấu”:

- Kiểu dữ liệu trong query không chặt chẽ, đôi lúc TypeScript chỉ đứng nhìn và… không cảnh báo gì 😅  
- Một số câu lệnh tạo ra SQL “thừa mứa”, nhìn mà muốn khóc.

RoxaVN bắt đầu hoang mang:  
> “Liệu có cần sử dụng 1 ORM cồng kềnh, khó kiểm soát sql. Phải chăng đã đến lúc tìm một người mới — ai đó đơn giản hơn, rõ ràng hơn, không drama hơn?” 💭  

Và rồi **Kysely** xuất hiện – nhẹ nhàng, tinh gọn, và chuẩn triết lý KISS 💡. Không cần entity phức tạp, không cần decorator hoa mỹ. Bạn tự viết query SQL theo cú pháp an toàn, vừa đơn giản, vừa kiểm soát toàn diện từng dòng câu lệnh. Kysely không cố làm phép màu — nó chỉ đưa cho bạn kiếm và khiên, để bạn chủ động chiến đấu với database như một SQL samurai 🥷.

Từ đó, RoxaVN chính thức chia tay TypeORM trong êm đẹp, và nắm tay Kysely bước tiếp trên con đường **đơn giản, mạnh mẽ, và rõ ràng**.

### 🎨 5. Mantine UI – Bộ áo đẹp mà nhẹ 💅  

Trước khi kể về Mantine, phải nói thật một điều: RoxaVN nói “không” với Tailwind”. Không phải Tailwind tệ, nhưng mà… mỗi lần nhìn thấy dòng code kiểu:

```html
<div class="flex flex-col justify-between items-center text-sm text-gray-700 bg-gradient-to-r from-blue-500 to-purple-600 hover:scale-105 transition-all duration-300 shadow-md rounded-lg p-4">
```

là tôi cảm giác như đang đọc thần chú để triệu hồi CSS thần thánh 🧙‍♂️. Không ai có thể bảo trì nổi những chuỗi class dài hơn cả đường Trường Sơn như vậy. Tailwind có thể hợp với các dự án nhỏ, nhưng với hệ thống lớn như RoxaVN, đọc code cũng phải thở oxy 😵‍💫

Giờ thì nói đến các UI framework “đối tác tiềm năng” của RoxaVN nhé 👇

- 🧱 Ant Design: đầy đủ component, tài liệu chi tiết, nhưng bundle nặng đến mức mở app lần đầu mà trình duyệt phải “vã mồ hôi” 🐘
- 🧩 Material UI: giao diện đẹp, tinh tế, nhưng component vẫn còn thiếu, và custom style thì… như đang chơi trò “đoán đúng 10 props mới đổi được màu nút” 🎨
- 🎭 PrimeReact: component phong phú, nhưng API hay thay đổi, giao diện mang phong cách hoài cổ 🗺️

Và rồi Mantine UI xuất hiện – như người hùng mặc giáp nhẹ bước ra giữa chiến trường ⚔️. Không quá phô trương, nhưng vừa đủ mạnh, đủ đẹp, và đủ dễ xài. Bộ component của Mantine vừa “ngon”, vừa có sẵn hook tiện ích như: useClipboard, useForm… Nói cách khác: chỉ cần import là bạn đã được “chăm sóc tận răng” 🪥. Không chỉ vậy, theme system của Mantine mạnh đến mức bạn có thể đổi giao diện app nhanh hơn cả đổi mood sau khi fix bug thành công 💅. Tùy biến màu sắc, spacing, dark mode, font – tất cả đều nhẹ nhàng và tinh tế.

## Mô hình tổng quan

RoxaVN là framework **fullstack**, lo luôn cả backend lẫn frontend. Nói cách khác, “trọn gói từ A đến Z”.

```mermaid
---
config:
  theme: neutral
---
flowchart LR
  subgraph L1["Users Layer"]
    provider["🏢 Provider"]
    consumer["🤵 Consumer"]
  end
  subgraph L2["Web application"]
    adminDashboard["📊 Admin Dashboard"]
    personalProfile["🪪 Personal Profile"]
    customApplication["🧩 Custom Application"]
  end
  subgraph L3["Backend"]
    webServer["💻 Web Server"]
    workerService["🔁 Worker Service"]
  end
  subgraph L4["Database"]
    postgres["🐘 Postgres"]
    redis["⚡ Redis"]
  end

  provider -- manage data --> adminDashboard
  consumer -- update info --> personalProfile
  L2 ==> L3
  L3 ==> L4
```

### 1. Lớp người dùng
1. **Nhà cung cấp:** tổ chức hoặc cá nhân “dựng cửa hàng, mở dịch vụ”, cung cấp đủ thứ cho khách hàng.
2. **Khách hàng:** người dùng cuối, là thượng đế của bạn 👑.

### 2. Giao diện người dùng
1. **Admin dashboard:** nơi nhà cung cấp vào “điều hành thế giới” — quản lý user, dịch vụ, v.v.  
   - 🛠️ Truy cập: `/admin/apps`
2. **Personal profile:** chỗ khách hàng tự “tút lại profile”, chỉnh tên, thay avatar, đổi mood.  
   - 👤 Truy cập: `/me`
3. **Custom application:** nếu thấy chưa đủ, bạn có thể “nấu món riêng”, phát triển ứng dụng web tùy mô hình kinh doanh.

### 3. Thành phần backend

Hệ thống của RoxaVN chia làm hai “nhân vật chính”: một anh “giao tiếp xã hội” và một anh “ở hậu trường làm việc quần quật” 😆  

#### 🛰️ 3.1. Web Server – Anh chàng nói nhiều  

Đây là mặt tiền của RoxaVN, nơi xử lý **RESTful API** và **WebSocket**. Nói cách khác, đây là “người phát ngôn chính thức” –  client hỏi gì, anh này trả lời; có socket kết nối, anh này chat lại liền. Không có web server thì cả hệ thống im như chùa mùa mưa. 🧘‍♂️

#### 🧱 3.2. Worker Service – Công nhân ẩn danh

Phía sau ánh đèn sân khấu, **Worker Service** là người cày cuốc thầm lặng:  
- Chạy **cronjob** định kỳ (kiểu như nhắc “Ê, hôm nay quét dữ liệu chưa?”).  
- Lắng nghe **event từ API hoặc database** rồi xử lý trong im lặng.
- Làm hết mấy việc “nặng nhọc” để Web Server không bị stress 🤯


#### 💻 Trong môi trường dev  

Khi bạn chạy `npm run dev` RoxaVN sẽ load cả Web Server lẫn Worker Service trong cùng một tiến trình. Tất cả cùng sống hòa bình, giúp dev test dễ dàng hơn – không cần mở 100 terminal. Chạy 1 lệnh, 2 anh lên sàn cùng lúc 🎭.

#### 🚀 Trong môi trường production

Khi deploy thật, mọi thứ nghiêm túc hơn:

- Lệnh `npm start` chỉ khởi động Web Server – để phục vụ client.
- Còn Worker Service được tách riêng:
    - Chạy cronjob `npx roxavn worker --schedule`
    - Chạy task lắng nghe event `npx roxavn worker --normal`

Nhờ tách riêng như vậy, hệ thống ổn định, dễ scale, và nếu Worker có “lăn ra ngủ quên”, Web Server vẫn tiếp tục hoạt động ngon lành 😴.

### 4. Database

Đây là tầng dưới cùng, đảm nhận lưu trữ dữ liệu với Postgres. Ngoài ra bạn có thể cache dữ liệu với Redis giúp tăng cường hiệu suất cho hệ thống.