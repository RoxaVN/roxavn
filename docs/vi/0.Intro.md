## Tại sao lại có RoxaVN

Tôi từng lăn lộn qua các thể loại dự án: game, blockchain, mạng xã hội, ERP, thương mại điện tử. Mỗi lần bắt đầu dự án, việc đầu tiên tôi phải làm là dựng lại cái “project base” — giống như mỗi lần nấu ăn phải rửa nồi, vo gạo, thổi cơm lại từ đầu. Lặp đi lặp lại riết chán, tôi mới nghĩ: “Ủa, sao mình không tạo luôn cái framework có sẵn hết mọi thứ, muốn gì chỉ cần ráp module như chơi Lego?”  
Thế là RoxaVN ra đời — mỗi module là một miếng Lego xịn, lập trình viên chỉ cần lắp ghép lại theo mô hình kinh doanh của riêng mình. Không cần làm đầu bếp, chỉ cần biết xào lại là có món ngon 😎 

## Triết lý thiết kế

Để module có thể “chạy tốt trên mọi địa hình”, chúng phải **đơn giản đến mức không thể đơn giản hơn nữa**. Nói cách khác, RoxaVN sống theo triết lý **KISS – Keep It Simple, Stupid**.

Mỗi module chỉ biết những việc cơ bản như tạo, sửa, xóa entity — không hoa mỹ, không phức tạp, không “deep learning” làm gì. Cả cách code cho RoxaVN cũng phải ngắn gọn, nhìn vào hiểu liền, không cần tài liệu dài lê thê. Code càng dài thì lỗi càng nhiều, dev càng mệt, PM càng stress, và QA càng buồn ngủ.

Trường hợp hoàn hảo nhất là **không cần code mà vẫn chạy được** – kiểu như “framework biết lo cho bạn hết”. Nếu đã có thư viện làm sẵn, thì chỉ cần chạy `npm install` mà thôi — đừng phát minh lại cái bánh xe 🤭

Tại sao tôi lại chọn triết lý KISS chứ không phải SOLID hay triết lý nào khác vì nó đơn giản dễ nhớ. Bản thân tôi cũng không nhớ SOLID là viết tắt của 5 từ gì 😂. Khi code bạn không cần nhớ phải tuân theo 5 quy tắc nào, chỉ cần nhớ **code ngắn nhất** có thể thôi.

## Lựa chọn công nghệ

Phần này giải thích rõ cho việc lựa chọn công nghệ để xây dựng nên RoxaVN

### 🏗️ 1. Monolith hay Microservices  

Ngày xưa, **Monolith** là “vua” — tất cả dồn vào một khối. Debug dễ, deploy nhanh, nhưng chỉ cần đụng nhẹ một tí là… “nổ toàn bộ”.  
Rồi người ta sinh ra **Microservices** — chia nhỏ hệ thống, mỗi service lo một việc.  
Nghe sang lắm, nhưng chạy rồi mới biết: “Một hệ thống, ngàn bug, triệu log” 😅  

#### 💀 Điểm yếu huyền thoại của Microservices  

1. **Quản lý mệt như nuôi bầy mèo** 🐈  
   Mỗi service là một con mèo: build riêng, deploy riêng, log riêng, bug riêng.  
   Có 30 service là bạn thành **người trông sở thú phần mềm**.  

2. **Đồng bộ dữ liệu = chơi xếp hình trong bão** 🌪️  
   Service A lưu user, B lưu order, C lưu payment.  
   Muốn thống kê doanh thu → chúc mừng, bạn unlock *minigame “Ghép Dữ Liệu Liên Service”*.  

3. **Transaction liên service: ác mộng thật sự** 😵  
   Rollback 3 service cùng lúc? Chúc bạn may mắn.  
   Dữ liệu nhất quán trong mơ, còn thực tế thì… “thôi đừng hỏi”.  

4. **Giao tiếp dễ ‘đột tử’** ⚡  
   Network là thứ “nay sống mai chết”.  
   Một service timeout, kéo theo cả chuỗi domino — log thì dài như biên niên sử công ty.  

5. **DevOps nhìn thấy là muốn chuyển nghề** 💀  
   Mỗi lần deploy phải build mấy chục image, đẩy mấy chục container.  
   Có Kubernetes thì đỡ hơn, nhưng cũng chỉ là “đỡ đau chứ chưa hết đau”.  

#### 💡 Modular Monolith – Người hùng thầm lặng

RoxaVN chọn **Modular Monolith**, vì nó giữ đúng tinh thần **KISS**:  

| Microservices | Modular Monolith (RoxaVN) |
|----------------|-----------------------------|
| Mỗi service chạy riêng → 10 app, 10 port, 10 container 😫 | Một lệnh `npm start` là lên hết 😌 |
| Transaction xuyên service → saga pattern, event bus, headache 💥 | Mọi thứ chung DB → rollback 1 phát ăn ngay 🧘 |
| API call → network delay, timeout, retry | Import module → chạy nhanh như ánh sáng ⚡ |
| Đồng bộ dữ liệu giữa các service là 1 thách thức | Truy vấn đơn giản vì tất cả dữ liệu trong 1 DB |

Thực tế thì Modular Monolith vẫn đang bị underrated một cách đau lòng 💔. Mọi người hay bị cuốn vào hype “micro-đủ-thứ”, trong khi tư tưởng **Modular** thực ra có thể áp dụng cho cả backend lẫn frontend luôn. Bạn đâu cần phải dựng nguyên một **microfrontend** phức tạp và nặng như con voi chỉ để hiển thị vài component nhỏ 😅. Với RoxaVN, chỉ cần:

```ts
import { AwesomeComponent } from "@roxavn/module-xyz";
```

và boom 💥 — bạn đã dùng component từ module khác ngon lành, không cần proxy, không cần build chéo, không cần cầu nguyện với webpack thần thánh.

Còn nếu bạn muốn chỉ tải component khi user thực sự cần, hãy tận dụng `dynamic import()` của ESModule – vừa giảm kích thước bundle ban đầu, vừa khiến user thấy app “mượt như Sunsilk” 🧈.

#### Module RoxaVN

Mỗi module RoxaVN sẽ là 1 Javascript package với git repo độc lập, chứa cả code backend lẫn frontend. Việc này giúp cho nhiều team có thể phát triển các module song song và không phụ thuộc với nhau. Module RoxaVN sẽ gồm 2 loại:

- **Module:** tương tự như service trong Microservices.
  Mỗi module có bảng riêng, không foreign key chéo. Nếu cần dữ liệu module khác, gọi API mà nó cung cấp.  
- **Plugin:** phần mở rộng cho module.
  Plugin có thể truy cập bảng của module chính qua cấu hình và thường có prefix `plugin-` trong package name. Ví dụ như `@roxavn/plugin-message-reaction` là plugin thêm tính năng reaction cho `@roxavn/module-message`

Ngoài ra những module dòi hỏi tính năng đặc thù hoặc hiệu suất cao nên tách ra như 1 hệ thống độc lập, không nên nằm trong RoxaVN (ví dụ như upload file với MinIO, hay stream video với Mediasoup, ...)

### ⚔️ 2. JavaScript song kiếm hợp bích cùng TypeScript  

JavaScript không phải “ngôn ngữ mạnh nhất vũ trụ”, nhưng lại là **ngôn ngữ được lòng cả backend lẫn frontend**. Và đó chính là lý do RoxaVN chọn nó làm bảo kiếm của mình 🥷

Khi **frontend và backend cùng nói chung một thứ tiếng**, bạn sẽ nhận được những buff sức mạnh sau:  

- 🧘‍♂️ **Code liền mạch, tâm hồn thanh tịnh**  
  Đang viết React quay sang NodeJS vẫn thấy thân quen, không còn cảnh đang `console.log` vui vẻ rồi chuyển sang `System.out.println` và mất mood.  

- 🔄 **Server – Client chung huyết thống**  
  Cả hai dùng chung thư viện, chung kiểu dữ liệu, chung niềm vui. Bạn chỉ cần định nghĩa request/response API ở một nơi, cả backend lẫn frontend đều hiểu — như hai người yêu cùng tài khoản Netflix ❤️  

- 👩‍💻 **Tuyển dev dễ như ăn bánh**  
  Không còn drama “ông này biết backend nhưng không biết React”, hay “chị kia chỉ làm frontend”. Giờ chỉ cần **một ngôn ngữ – full stack liền mạch**. Dev frontend có thể làm backend, dev backend có thể… build giao diện (nếu dám 😏).  

Nhưng đừng xem thường JavaScript! Dù không nhanh như Rust, không gọn như Go, không “cứng” như C++, nó lại có một siêu năng lực mà mấy ngôn ngữ kia mơ cũng không có:

> 💥 Bạn có thể lưu **mã JavaScript trong database**, backend chỉ việc lấy ra, **chạy thẳng luôn!**  

Không cần build, không cần compile, không cần cầu nguyện. Tính năng này giúp RoxaVN **tùy biến linh hoạt như ninja biến hình**, và được dùng triệt để trong `@roxavn/module-workflow` để xử lý mọi logic theo yêu cầu.  

Còn **TypeScript** thì sao? Đó chính là **thanh kiếm thứ hai** của RoxaVN ⚔️  

Nếu JavaScript là nghệ sĩ tự do, thì TypeScript là người quản lý khó tính — đảm bảo mọi input/output của API đều gọn gàng, rõ ràng, không nhầm kiểu.  

Mỗi module và plugin trong RoxaVN là một package **ESModule** chuẩn chỉnh, giúp build client nhẹ hơn với **Tree Shaking** 🪶 

RoxaVN dùng với Node 20+ và npm. Trong tương lai sẽ cân nhắc chuyển sang Bun.

> RoxaVN dùng JavaScript để **linh hoạt như nước** và TypeScript để **chắc chắn như thép**.

### 🔄 3. RESTful vs GraphQL – Cuộc chiến không hồi kết ⚔️

Thế giới backend chia làm hai phe:  
- Một bên là **RESTful API** – lão làng, ổn định, dễ hiểu.  
- Bên kia là **GraphQL** – trẻ trung, thông minh, và... hơi “đòi hỏi” 😏

| Tiêu chí               | RESTful                        | GraphQL                        |
| ---------------------- | ------------------------------ | ------------------------------ |
| Cách tiếp cận          | Mỗi endpoint cho 1 tài nguyên  | Một endpoint cho tất cả        |
| Dễ học                 | 🟢 Dễ như ăn bánh              | 🔴 Hơi khó, cần hiểu schema    |
| Linh hoạt dữ liệu      | 🔴 Trả cả phần không cần       | 🟢 Lấy đúng thứ mình muốn      |
| Debug & Cache          | 🟢 Dễ kiểm soát                | 🔴 Khó vì query động           |

RESTful là “người bạn cũ hiểu bạn, không phức tạp nhưng đáng tin”, còn GraphQL là “người mới quyến rũ, thông minh, nhưng đòi hỏi kiên nhẫn và hiểu sâu”. Với triết lý KISS, RoxaVN chọn RESTful – vì đôi khi đơn giản chính là tối ưu 😎.

#### 🧩 RESTful “kiểu RoxaVN” – Đơn giản nhưng linh hoạt

Trong RoxaVN, mỗi RESTful API chỉ có một nhiệm vụ duy nhất trong đời – thêm thì chỉ thêm, lấy thì chỉ lấy, xóa thì… nói lời tạm biệt 👋. Không đa nhiệm, không lằng nhằng, không “vừa insert vừa update vừa join” như một mớ spaghetti 🍝.

#### 🧠 Nguyên tắc vàng của API RoxaVN  
> “Server chỉ nên làm một việc, và làm việc đó thật tốt.”  

Vì vậy, mỗi API được thiết kế tối giản:  
- `POST /users` → thêm một người dùng 👶  
- `GET /users/:id` → lấy thông tin một người dùng 👀  
- `GET /users` → lấy danh sách người dùng 📜  

Và dừng ở đó. Không có chuyện join A với B rồi B lại join tiếp với C, vì kiểu join “tam đại đồng đường” này khiến query nặng nề, khó bảo trì, và dev phải đọc SQL dài hơn cả hợp đồng lao động 😩. Thay vào đó, RoxaVN **chỉ join trực tiếp giữa hai bảng có quan hệ gần gũi** – kiểu như “cha con”, không dây dưa đến “họ hàng bên ngoại của người bạn hàng xóm”. Ngắn gọn, dễ hiểu, dễ debug, và nhanh như chớp ⚡

#### 🔄 Phần join – để client lo!  

RoxaVN tin tưởng client như một người bạn thông minh:
> “Cậu thích join gì thì join, thích lấy gì thì lấy, tớ chỉ trả đúng phần của tớ thôi.”  

Server được giữ đơn giản và dễ tái sử dụng, còn client thì có đủ công cụ để tự ráp dữ liệu theo nhu cầu riêng – như chơi Lego nhưng không cần xin phép backend 🧱

Cụ thể, RoxaVN trang bị cho frontend 2 “vũ khí lợi hại”:  

- 🧭 component `ApiReference` – giúp client liên kết dữ liệu từ nhiều API một cách tự nhiên, dễ đọc.  
- ⚡ hook `useApiBatchQuery()` – cho phép gọi nhiều API cùng lúc rồi ráp kết quả về như pro.  

Cả hai đều được học hỏi ý tưởng từ [`ReferenceField` của React-Admin](https://marmelab.com/react-admin/ReferenceField.html) nhưng được tinh chỉnh lại để “ngon, gọn, nhẹ, chuẩn RoxaVN style” 😎.

#### 👙 Đừng show tất cả bạn có

Tuy client có thể join bất cứ thứ gì mình muốn, nhưng cũng nên nhớ:  
> “Không phải cứ có nhiều dữ liệu là user hạnh phúc hơn.” 😅  

Đừng bày ra một mâm data khổng lồ ngay từ đầu, hãy để user khám phá từng phần một cách tự nhiên – mở đến đâu, load đến đó, show vừa đủ, còn lại để user tò mò tiếp 💡. RoxaVN khuyến khích thiết kế UI theo hướng “khám phá dần” (progressive reveal):  
- Ban đầu chỉ hiển thị thông tin chính.  

- Khi user click vào chi tiết hoặc mở rộng, mới gọi thêm dữ liệu cần thiết.

Như vậy vừa tiết kiệm tài nguyên, vừa giúp trải nghiệm người dùng “mượt mà như gió” 🌬️

### 🧙‍♂️ 4. Postgres – Thần giữ của 💰  

Trong thế giới lập trình, **data là vàng**, mà đã là vàng thì phải có thần giữ của canh chừng cẩn thận. RoxaVN chọn **PostgreSQL** – vị thần vừa “ngầu”, vừa “có học”, vừa “không đòi tiền bản quyền” 😎  

Vì sao không chọn NoSQL?  
Vì RoxaVN cần **transaction**, mà NoSQL thì… thôi, nói nhẹ nhàng là “sống tự do quá mức” 😅  

#### 🔥 Những lý do khiến Postgres xứng đáng ngồi ghế “thần giữ của”  

- 🪄 **Full Text Search cực mạnh:**  
  Không cần rước thêm ElasticSearch về nhà cho tốn RAM, tốn công đồng bộ. Chỉ cần Postgres là đủ – *simple is beautiful*.  

- 🗺️ **PostGIS – phép thuật bản đồ:**  
  Truy vấn theo tọa độ, khoảng cách, hình dạng... Postgres làm ngon hết. Nói thật, chỉ thiếu mỗi việc nó vẽ bản đồ ra giấy cho bạn thôi 😂  

- 📡 **Bắn event realtime cho client:**  
  Khi data thay đổi, Postgres có thể “bắn tín hiệu” cho app biết ngay – như thể database đang thì thầm: *“Ê, dữ liệu mày vừa đổi kìa.”*  

- 🧰 **Và cả tá tính năng thần thánh khác:**  
  Từ JSONB, trigger, view, function, đến extension… đủ để bạn xây cả lâu đài dữ liệu mà không cần thêm lính.  

#### 🪶 Bonus: Hóa thân thành CockroachDB

Nếu bạn muốn Postgres của mình có **siêu năng lực phân tán**, chạy đa node, chịu lỗi như “gián đến từ hậu tận thế”, thì chỉ cần chuyển sang **CockroachDB** — cùng cú pháp SQL, không cần sửa code, và hệ thống của bạn sẽ “bất tử” như boss cuối trong game 💀

### ⚛️ 5. React – Cánh tay phải của RoxaVN 💙  

RoxaVN chọn **React** không phải vì hype, mà vì nó có hệ sinh thái to như chợ Bến Thành. Cần vẽ flow? Có **ReactFlow**. Cần editor xịn? Có **Puck Editor**. Cần biểu đồ lung linh? **Recharts** lo hết 🎨 và 1 loạt các framework UI khác nữa. Một hệ sinh thái có đủ “đồ chơi” như vậy, dev chỉ cần biết cách import đúng là có thể “sống vui – code khỏe” 🤓.

Tôi cũng từng *crush* **SolidJS** – nhỏ này nhanh, gọn, render lẹ như ninja. Nhưng tiếc là “đi chơi” với nó hơi cô đơn, vì thư viện còn ít.  Muốn vẽ biểu đồ hay kéo thả node là phải tự cầm dao… à nhầm, code tay 😅. Còn **Vue** và **Angular** thì sao? Hai ông này cũng mạnh, cộng đồng đông, nhưng lại có thói quen “trộn đồ ăn” – code JS mà phải khai báo UI trong file HTML. Mỗi lần nhảy qua nhảy lại giữa script và template, tôi cảm giác như xem phim mà phải tua tới lui phụ đề 🤯.

**React** với **JSX** thì khác – HTML và JS sống chung một nhà, hòa hợp như cặp đôi song ca ăn ý 🎤. Bạn code liền mạch, suy nghĩ không bị ngắt quãng, và có thể viết UI như đang kể chuyện tình giữa component và state 💞.

#### 💔 React Router vs Next.js  

Thị trường **framework fullstack** cho React thì nhiều vô kể: Next.js, Gatsby, Astro… nói chung là “đi 3 bước là đụng một framework mới ra lò”. Nhưng RoxaVN lại có đặc thù riêng:

> Mỗi module là một thế giới nhỏ, và **mỗi module export ra các page riêng**.  
> Khi chạy, RoxaVN sẽ tự động gom tất cả các page đó lại, ráp thành một website hoàn chỉnh – như ghép Lego thành lâu đài 🏰  

Vấn đề là… Next.js không chịu chơi kiểu đó 😩. Nó bắt bạn phải đặt tất cả page trong một thư mục `pages` cố định, giống như bắt dev phải dồn hết code vào một vali rồi bảo “tự sắp đi nhé”. Cộng đồng Next.js thì to như fandom K-pop, tài liệu nhiều như tiểu thuyết, nhưng tiếc là RoxaVN và Next.js không cùng “tần số tự do”. Thế là đành nói lời chia tay nhẹ nhàng:

> “Không phải lỗi của em, cũng chẳng phải lỗi của anh – chỉ là ta không hợp cấu trúc thư mục thôi.” 😢  

Gatsby và Astro cũng thử bước vào, nhưng rồi cũng phải ra đi vì… quá cứng nhắc về định tuyến (routing).  

Chỉ có **React Router** – người bạn “cũ” (tiền thân là Remix) – mới thật sự hiểu RoxaVN cần gì:  

> “Custom route tự do, đường nào cũng được, miễn đừng crash.” 🛣️

Và thế là RoxaVN đã tìm thấy tri kỷ của mình ❤️. Một người bạn linh hoạt, đáng tin, và không bắt dev phải theo khuôn mẫu.

### 🧩 6. Kysely - Cuộc gặp gỡ định mệnh

Những phiên bản đầu tiên của RoxaVN từng “yêu say đắm” **TypeORM** – một công cụ ORM giúp đồng bộ entity với database và tạo migration tự động. Ban đầu, mọi thứ đều đẹp: chỉ cần định nghĩa entity là database tự sinh ra, dev không cần động tay vào SQL — cảm giác sung sướng như có AI viết hộ code 🧠✨. Nhưng càng gắn bó lâu, TypeORM càng lộ nhiều “tật xấu”:

- Kiểu dữ liệu trong query không chặt chẽ, đôi lúc TypeScript chỉ đứng nhìn và… không cảnh báo gì 😅  
- Một số câu lệnh tạo ra SQL “thừa mứa”, nhìn mà muốn khóc.

RoxaVN bắt đầu hoang mang:  
> “Liệu có cần sử dụng 1 ORM cồng kềnh, khó kiểm soát sql. Phải chăng đã đến lúc tìm một người mới — ai đó đơn giản hơn, rõ ràng hơn, không drama hơn?” 💭  

Và rồi **Kysely** xuất hiện – nhẹ nhàng, tinh gọn, và chuẩn triết lý KISS 💡. Không cần entity phức tạp, không cần decorator hoa mỹ. Bạn tự viết query SQL theo cú pháp an toàn, vừa đơn giản, vừa kiểm soát toàn diện từng dòng câu lệnh. Kysely không cố làm phép màu — nó chỉ đưa cho bạn kiếm và khiên, để bạn chủ động chiến đấu với database như một SQL samurai 🥷.

Từ đó, RoxaVN chính thức chia tay TypeORM trong êm đẹp, và nắm tay Kysely bước tiếp trên con đường **đơn giản, mạnh mẽ, và rõ ràng**.

### 🎨 7. Mantine UI – Bộ áo đẹp mà nhẹ 💅  

Trước khi kể về Mantine, phải nói thật một điều: RoxaVN nói “không” với Tailwind”. Không phải Tailwind tệ, nhưng mà… mỗi lần nhìn thấy dòng code kiểu:

```html
<div class="flex flex-col justify-between items-center text-sm text-gray-700 bg-gradient-to-r from-blue-500 to-purple-600 hover:scale-105 transition-all duration-300 shadow-md rounded-lg p-4">
```
là tôi cảm giác như đang đọc thần chú để triệu hồi CSS thần thánh 🧙‍♂️. Không ai có thể bảo trì nổi những chuỗi class dài hơn cả đường Trường Sơn như vậy. Tailwind có thể hợp với các dự án nhỏ, nhưng với hệ thống lớn như RoxaVN, đọc code cũng phải thở oxy 😵‍💫

Giờ thì nói đến các UI framework “đối tác tiềm năng” của RoxaVN nhé 👇

- 🧱 Ant Design: đầy đủ component, tài liệu chi tiết, nhưng bundle nặng đến mức mở app lần đầu mà trình duyệt phải “vã mồ hôi” 🐘
- 🧩 Material UI: giao diện đẹp, tinh tế, nhưng component vẫn còn thiếu, và custom style thì… như đang chơi trò “đoán đúng 10 props mới đổi được màu nút” 🎨
- 🎭 PrimeReact: component phong phú, nhưng API hay thay đổi, giao diện mang phong cách hoài cổ 🗺️

Và rồi Mantine UI xuất hiện – như người hùng mặc giáp nhẹ bước ra giữa chiến trường ⚔️. Không quá phô trương, nhưng vừa đủ mạnh, đủ đẹp, và đủ dễ xài. Bộ component của Mantine vừa “ngon”, vừa có sẵn hook tiện ích như: useClipboard, useForm… Nói cách khác: chỉ cần import là bạn đã được “chăm sóc tận răng” 🪥. Không chỉ vậy, theme system của Mantine mạnh đến mức bạn có thể đổi giao diện app nhanh hơn cả đổi mood sau khi fix bug thành công 💅. Tùy biến màu sắc, spacing, dark mode, font – tất cả đều nhẹ nhàng và tinh tế.
